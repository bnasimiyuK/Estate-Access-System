{
    "sourceFile": "backend/server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1763619285298,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1763619541459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n     getVisitorPasses,\n     payController,\n     getPaymentStatusController\n } from \"./controllers/residentsController.js\";\n-\n+import paymentsRoutes from \"./routes/paymentRoutes.js\";\n // =====================================\n // EXPRESS APP SETUP\n // =====================================\n const app = express();\n@@ -108,9 +108,9 @@\n // ROUTES\n // =====================================\n app.use(\"/api/auth\", authRoutes);\n app.use(\"/api/residents\", residentsRoutes);\n-\n+app.use(\"/api/payments\", paymentsRoutes);\n // DIRECT ROUTE BINDINGS FOR CONTROLLERS (if needed)\n app.get(\"/api/residents/membership\", verifyToken, getMembershipRequests);\n app.get(\"/api/residents/approved\", verifyToken, getApprovedResidents);\n app.get(\"/api/residents/visitorsaccess\", verifyToken, getVisitorPasses);\n"
                },
                {
                    "date": 1763624501644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,13 +67,13 @@\n \n // =====================================\n // MPESA CONFIG\n // =====================================\n-export const SHORTCODE = process.env.MPESA_SHORTCODE;\n-export const PASSKEY = process.env.MPESA_PASSKEY;\n+export const SHORTCODE = process.env.MPESA_SHORTCODE || 174379;\n+export const PASSKEY = process.env.MPESA_PASSKEY  || bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919;\n export const CONSUMER_KEY = process.env.MPESA_CONSUMER_KEY;\n-export const CONSUMER_SECRET = process.env.MPESA_CONSUMER_SECRET;\n-export const CALLBACK_URL = process.env.MPESA_CALLBACK_URL;\n+export const CONSUMER_SECRET = process.env.MPESA_CONSUMER_SECRET || i3JqaV9P75jf5Uz60jhG2R4Ph4Ix9DJs2DbM8UvfCHIjfu2BOmO5i1UTjDeAc2Aj;\n+export const CALLBACK_URL = process.env.MPESA_CALLBACK_URL || https://yessenia-anthropocentric-nonpersonally.ngrok-free.dev/api/residents/payment-callback;\n \n // =====================================\n // GET MPESA TOKEN\n // =====================================\n"
                },
                {
                    "date": 1763624529888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,9 +69,9 @@\n // MPESA CONFIG\n // =====================================\n export const SHORTCODE = process.env.MPESA_SHORTCODE || 174379;\n export const PASSKEY = process.env.MPESA_PASSKEY  || bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919;\n-export const CONSUMER_KEY = process.env.MPESA_CONSUMER_KEY;\n+export const CONSUMER_KEY = process.env.MPESA_CONSUMER_KEY || kmOLZ06AIGR4EtIovle2fwsLQU51YbWjdnSG516peEqwADAG;\n export const CONSUMER_SECRET = process.env.MPESA_CONSUMER_SECRET || i3JqaV9P75jf5Uz60jhG2R4Ph4Ix9DJs2DbM8UvfCHIjfu2BOmO5i1UTjDeAc2Aj;\n export const CALLBACK_URL = process.env.MPESA_CALLBACK_URL || https://yessenia-anthropocentric-nonpersonally.ngrok-free.dev/api/residents/payment-callback;\n \n // =====================================\n"
                },
                {
                    "date": 1763624731256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,8 +28,9 @@\n     payController,\n     getPaymentStatusController\n } from \"./controllers/residentsController.js\";\n import paymentsRoutes from \"./routes/paymentRoutes.js\";\n+\n // =====================================\n // EXPRESS APP SETUP\n // =====================================\n const app = express();\n@@ -65,15 +66,16 @@\n         process.exit(1);\n     });\n \n // =====================================\n-// MPESA CONFIG\n+// MPESA CONFIG (Syntax Corrected - Default strings now have quotes)\n // =====================================\n-export const SHORTCODE = process.env.MPESA_SHORTCODE || 174379;\n-export const PASSKEY = process.env.MPESA_PASSKEY  || bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919;\n-export const CONSUMER_KEY = process.env.MPESA_CONSUMER_KEY || kmOLZ06AIGR4EtIovle2fwsLQU51YbWjdnSG516peEqwADAG;\n-export const CONSUMER_SECRET = process.env.MPESA_CONSUMER_SECRET || i3JqaV9P75jf5Uz60jhG2R4Ph4Ix9DJs2DbM8UvfCHIjfu2BOmO5i1UTjDeAc2Aj;\n-export const CALLBACK_URL = process.env.MPESA_CALLBACK_URL || https://yessenia-anthropocentric-nonpersonally.ngrok-free.dev/api/residents/payment-callback;\n+// NOTE: Please ensure your .env uses MPESA_SHORTCODE, MPESA_PASSKEY, etc.\n+export const SHORTCODE = process.env.MPESA_SHORTCODE || \"174379\";\n+export const PASSKEY = process.env.MPESA_PASSKEY || \"bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919\";\n+export const CONSUMER_KEY = process.env.MPESA_CONSUMER_KEY || \"kmOLZ06AIGR4EtIovle2fwsLQU51YbWjdnSG516peEqwADAG\";\n+export const CONSUMER_SECRET = process.env.MPESA_CONSUMER_SECRET || \"i3JqaV9P75jf5Uz60jhG2R4Ph4Ix9DJs2DbM8UvfCHIjfu2BOmO5i1UTjDeAc2Aj\";\n+export const CALLBACK_URL = process.env.MPESA_CALLBACK_URL || \"https://yessenia-anthropocentric-nonpersonally.ngrok-free.dev/api/residents/payment-callback\";\n \n // =====================================\n // GET MPESA TOKEN\n // =====================================\n@@ -93,15 +95,24 @@\n \n // =====================================\n // MIDDLEWARE\n // =====================================\n-app.use(cors({\n-    origin: ['http://localhost:3000', 'http://127.0.0.1:3000'],\n+const corsOptions = {\n+    // 1. Specify the exact origin allowed (your frontend port)\n+    origin: ['http://localhost:3000', 'http://127.0.0.1:3000'], \n+    \n+    // 2. Allow credentials (important for sending cookies/JWT tokens)\n     credentials: true,\n-    methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n-    allowedHeaders: [\"Content-Type\", \"Authorization\"]\n-}));\n+    \n+    // 3. Allow all necessary methods (GET, POST, PATCH, DELETE)\n+    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],\n+    \n+    // 4. Specify allowed headers, including 'Authorization' for Bearer tokens\n+    allowedHeaders: ['Content-Type', 'Authorization'] \n+};\n \n+app.use(cors(corsOptions)); // Apply CORS middleware\n+\n app.use(express.json());\n app.use(express.static(path.join(__dirname, \"frontend\")));\n \n // =====================================\n@@ -117,29 +128,64 @@\n app.post(\"/api/residents/pay\", verifyToken, payController);\n app.get(\"/api/residents/payment-status\", verifyToken, getPaymentStatusController);\n \n // =====================================\n-// MPESA CALLBACK\n+// MPESA CALLBACK (Updated logic for M-Pesa standard structure)\n // =====================================\n app.post(\"/api/residents/payment-callback\", async (req, res) => {\n     try {\n-        const pool = await dbPool;\n-        const { phone, resultCode } = req.body;\n-        if (!phone) return res.status(400).send(\"Phone required\");\n-        const status = resultCode === 0 ? \"Verified\" : \"failed\";\n-        await pool.request()\n-            .input(\"PhoneNumber\", sql.VarChar(20), phone)\n-            .input(\"Status\", sql.VarChar(20), status)\n-            .query(`\n-                UPDATE Payments\n-               SET Status = @Status, VerifiedDate = GETDATE()\n-                WHERE PhoneNumber = @PhoneNumber AND Status = 'pending'\n-            `);\n+        // M-Pesa callback data is usually nested deep\n+        const callbackData = req.body.Body?.stkCallback;\n+        if (!callbackData) {\n+            console.warn(\"Received invalid M-Pesa callback body:\", req.body);\n+            return res.status(400).send(\"Invalid callback data structure\");\n+        }\n \n-        res.status(200).send(\"OK\");\n+        const resultCode = callbackData.ResultCode;\n+        const checkoutRequestID = callbackData.CheckoutRequestID;\n+        const metadata = callbackData.CallbackMetadata?.Item;\n+        \n+        let mpesaReceiptNumber = null;\n+        let phoneNumber = null;\n+\n+        if (resultCode === 0 && metadata) {\n+            // Success: Extract essential details\n+            mpesaReceiptNumber = metadata.find(item => item.Name === 'MpesaReceiptNumber')?.Value;\n+            phoneNumber = metadata.find(item => item.Name === 'PhoneNumber')?.Value;\n+        }\n+\n+        // Determine status\n+        const status = resultCode === 0 ? \"Verified\" : \"Failed\";\n+\n+        // Only update if we have a way to link it back, usually CheckoutRequestID is the primary key for the pending record\n+        if (checkoutRequestID) {\n+            const pool = await dbPool;\n+            \n+            // The query should ideally link on CheckoutRequestID stored during STK push\n+            // But since the current DB schema requires updating based on phone, we'll use that (though less reliable)\n+            // A better query would use a stored CheckoutRequestID\n+            await pool.request()\n+                .input(\"PhoneNumber\", sql.VarChar(20), phoneNumber || '')\n+                .input(\"Status\", sql.VarChar(20), status)\n+                .input(\"ReceiptNumber\", sql.VarChar(50), mpesaReceiptNumber || null)\n+                .query(`\n+                    -- NOTE: Linking by PhoneNumber is risky. Linking by CheckoutRequestID is safer.\n+                    UPDATE Payments\n+                    SET Status = @Status, \n+                        VerifiedDate = GETDATE(),\n+                        MpesaReceiptNumber = @ReceiptNumber -- Assuming you add this column\n+                    WHERE PhoneNumber = @PhoneNumber AND Status = 'Pending';\n+                `);\n+        } else {\n+            console.error(\"M-Pesa Callback missing CheckoutRequestID.\");\n+        }\n+\n+        // Send a 200 OK response back to the M-Pesa API regardless of payment status\n+        res.status(200).send(\"C2B Callback received successfully\");\n     } catch (err) {\n         console.error(\"Payment callback error:\", err);\n-        res.status(500).send(\"Error\");\n+        // Do NOT send a 500 status to M-Pesa, as it may retry indefinitely. Send 200.\n+        res.status(200).send(\"Internal processing error\");\n     }\n });\n \n // =====================================\n@@ -153,9 +199,9 @@\n // CRITICAL FIX â€” START SERVER ONLY AFTER DB CONNECTION\n // =====================================\n async function startServer() {\n     try {\n-        await dbPool; // wait for DB\n+        await dbPool; // wait for DB connection to resolve\n \n         console.log(\"Starting Express server...\");\n         const PORT = process.env.PORT || 4050;\n \n@@ -168,30 +214,5 @@\n         process.exit(1);\n     }\n }\n \n-startServer();\n-// ----------------------------------------------------\n-// ðŸŸ¢ CORS CONFIGURATION (The Fix)\n-// ----------------------------------------------------\n-\n-const corsOptions = {\n-    // 1. Specify the exact origin allowed (your frontend port)\n-    origin: 'http://localhost:3000', \n-    \n-    // 2. Allow credentials (important for sending cookies/JWT tokens)\n-    credentials: true,\n-    \n-    // 3. Allow all necessary methods (GET, POST, PATCH, DELETE)\n-    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],\n-    \n-    // 4. Specify allowed headers, including 'Authorization' for Bearer tokens\n-    allowedHeaders: ['Content-Type', 'Authorization'] \n-};\n-\n-app.use(cors(corsOptions)); // Apply CORS middleware\n-\n-// ----------------------------------------------------\n-\n-// ... app.use(express.json());\n-// ... app.use('/api/membership', membershipRoutes);\n-// ... Start server on port 4050\n\\ No newline at end of file\n+startServer();\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763640991832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,13 +21,14 @@\n import { verifyToken } from \"./middleware/authMiddleware.js\";\n \n // Controllers (for optional direct bindings)\n import { \n-    getMembershipRequests, \n+    getMembershipRequests, // This function will be used for both resident and admin membership listing\n     getApprovedResidents, \n     getVisitorPasses,\n     payController,\n-    getPaymentStatusController\n+    getPaymentStatusController,\n+    approveResidentController // Assuming you have an approve controller\n } from \"./controllers/residentsController.js\";\n import paymentsRoutes from \"./routes/paymentRoutes.js\";\n \n // =====================================\n@@ -120,15 +121,27 @@\n // =====================================\n app.use(\"/api/auth\", authRoutes);\n app.use(\"/api/residents\", residentsRoutes);\n app.use(\"/api/payments\", paymentsRoutes);\n-// DIRECT ROUTE BINDINGS FOR CONTROLLERS (if needed)\n+\n+// DIRECT ROUTE BINDINGS FOR RESIDENTS (if needed)\n app.get(\"/api/residents/membership\", verifyToken, getMembershipRequests);\n app.get(\"/api/residents/approved\", verifyToken, getApprovedResidents);\n app.get(\"/api/residents/visitorsaccess\", verifyToken, getVisitorPasses);\n app.post(\"/api/residents/pay\", verifyToken, payController);\n app.get(\"/api/residents/payment-status\", verifyToken, getPaymentStatusController);\n \n+// CRITICAL ADMIN ROUTES\n+// FIX: Adds the missing route definition for the admin dashboard to fetch all membership requests\n+app.get('/api/admin/memberships', verifyToken, getMembershipRequests); \n+// NOTE: Assuming getMembershipRequests fetches ALL requests (Pending/Approved/Rejected)\n+// The frontend handles filtering for \"Requests\" vs \"Records\"\n+\n+// Assuming you also need a route for approving a resident request:\n+// This endpoint is used by the frontend when clicking the \"Approve\" button\n+// app.post('/api/admin/approveResident', verifyToken, approveResidentController); \n+\n+\n // =====================================\n // MPESA CALLBACK (Updated logic for M-Pesa standard structure)\n // =====================================\n app.post(\"/api/residents/payment-callback\", async (req, res) => {\n"
                },
                {
                    "date": 1763674335108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n import { verifyToken } from \"./middleware/authMiddleware.js\";\n \n // Controllers (for optional direct bindings)\n import { \n-    getMembershipRequests, // This function will be used for both resident and admin membership listing\n+    getMembershipRequests, // Used for both resident and admin membership listing\n     getApprovedResidents, \n     getVisitorPasses,\n     payController,\n     getPaymentStatusController,\n@@ -129,19 +129,66 @@\n app.get(\"/api/residents/visitorsaccess\", verifyToken, getVisitorPasses);\n app.post(\"/api/residents/pay\", verifyToken, payController);\n app.get(\"/api/residents/payment-status\", verifyToken, getPaymentStatusController);\n \n-// CRITICAL ADMIN ROUTES\n-// FIX: Adds the missing route definition for the admin dashboard to fetch all membership requests\n+\n+// =========================================================================\n+// âœ… ADMIN DASHBOARD ROUTES FIX (Addresses all four 404 errors)\n+// =========================================================================\n+\n+// 1. GET http://localhost:3000/api/dashboard/summary (404 FIX)\n+app.get(\"/api/dashboard/summary\", verifyToken, async (req, res) => {\n+    try {\n+        const pool = await dbPool;\n+        // Example: Fetch counts of key entities\n+        const summaryResult = await pool.request().query(`\n+            SELECT\n+                (SELECT COUNT(*) FROM Residents WHERE Status = 'Approved') as ApprovedResidents,\n+                (SELECT COUNT(*) FROM MembershipRequests WHERE Status = 'Pending') as PendingRequests,\n+                (SELECT COUNT(*) FROM VisitorPasses WHERE CreatedDate > DATEADD(day, -7, GETDATE())) as WeeklyVisitors;\n+        `);\n+        \n+        res.status(200).json(summaryResult.recordset[0]);\n+    } catch (err) {\n+        console.error(\"Error fetching dashboard summary:\", err);\n+        res.status(500).json({ message: \"Failed to fetch dashboard summary.\" });\n+    }\n+});\n+\n+// 2. GET http://localhost:3000/api/memberships/records (404 FIX)\n+app.get(\"/api/memberships/records\", verifyToken, getApprovedResidents); \n+// Assumption: getApprovedResidents returns the list of approved members (the \"records\")\n+// If getApprovedResidents only returns the approved list, this handles the route.\n+\n+// 3. GET http://localhost:3000/api/access/chart (404 FIX)\n+app.get(\"/api/access/chart\", verifyToken, async (req, res) => {\n+    try {\n+        const pool = await dbPool;\n+        // Example: Fetch access data for charting (e.g., daily entries/passes)\n+        const chartDataResult = await pool.request().query(`\n+            SELECT TOP 7 \n+                CAST(CreatedDate AS DATE) as Date, \n+                COUNT(*) as TotalPasses \n+            FROM VisitorPasses \n+            GROUP BY CAST(CreatedDate AS DATE)\n+            ORDER BY Date DESC;\n+        `);\n+        \n+        res.status(200).json(chartDataResult.recordset);\n+    } catch (err) {\n+        console.error(\"Error fetching chart data:\", err);\n+        res.status(500).json({ message: \"Failed to fetch chart data.\" });\n+    }\n+});\n+\n+// 4. GET http://localhost:3000/api/memberships/requests (404 FIX)\n+app.get(\"/api/memberships/requests\", verifyToken, getMembershipRequests);\n+// Assumption: getMembershipRequests returns ALL requests, including pending ones (the \"requests\").\n+\n+// CRITICAL ADMIN ROUTE EXAMPLE (Already defined in your original code but kept for context)\n app.get('/api/admin/memberships', verifyToken, getMembershipRequests); \n-// NOTE: Assuming getMembershipRequests fetches ALL requests (Pending/Approved/Rejected)\n-// The frontend handles filtering for \"Requests\" vs \"Records\"\n \n-// Assuming you also need a route for approving a resident request:\n-// This endpoint is used by the frontend when clicking the \"Approve\" button\n-// app.post('/api/admin/approveResident', verifyToken, approveResidentController); \n \n-\n // =====================================\n // MPESA CALLBACK (Updated logic for M-Pesa standard structure)\n // =====================================\n app.post(\"/api/residents/payment-callback\", async (req, res) => {\n"
                },
                {
                    "date": 1763674357484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,231 +1,231 @@\n-// =====================================\n-// LOAD ENVIRONMENT VARIABLES\n-// =====================================\n-import dotenv from \"dotenv\";\n-dotenv.config();\n+    // =====================================\n+    // LOAD ENVIRONMENT VARIABLES\n+    // =====================================\n+    import dotenv from \"dotenv\";\n+    dotenv.config();\n \n-// =====================================\n-// IMPORTS\n-// =====================================\n-import express from \"express\";\n-import cors from \"cors\";\n-import path from \"path\";\n-import { fileURLToPath } from \"url\";\n-import sql from \"mssql\";\n-import axios from \"axios\";\n+    // =====================================\n+    // IMPORTS\n+    // =====================================\n+    import express from \"express\";\n+    import cors from \"cors\";\n+    import path from \"path\";\n+    import { fileURLToPath } from \"url\";\n+    import sql from \"mssql\";\n+    import axios from \"axios\";\n \n-// Import routes\n-import authRoutes from \"./routes/authRoutes.js\";\n-import residentsRoutes from \"./routes/residentsRoutes.js\";\n-// Middleware\n-import { verifyToken } from \"./middleware/authMiddleware.js\";\n+    // Import routes\n+    import authRoutes from \"./routes/authRoutes.js\";\n+    import residentsRoutes from \"./routes/residentsRoutes.js\";\n+    // Middleware\n+    import { verifyToken } from \"./middleware/authMiddleware.js\";\n \n-// Controllers (for optional direct bindings)\n-import { \n-    getMembershipRequests, // This function will be used for both resident and admin membership listing\n-    getApprovedResidents, \n-    getVisitorPasses,\n-    payController,\n-    getPaymentStatusController,\n-    approveResidentController // Assuming you have an approve controller\n-} from \"./controllers/residentsController.js\";\n-import paymentsRoutes from \"./routes/paymentRoutes.js\";\n+    // Controllers (for optional direct bindings)\n+    import { \n+        getMembershipRequests, // This function will be used for both resident and admin membership listing\n+        getApprovedResidents, \n+        getVisitorPasses,\n+        payController,\n+        getPaymentStatusController,\n+        approveResidentController // Assuming you have an approve controller\n+    } from \"./controllers/residentsController.js\";\n+    import paymentsRoutes from \"./routes/paymentRoutes.js\";\n \n-// =====================================\n-// EXPRESS APP SETUP\n-// =====================================\n-const app = express();\n-const __filename = fileURLToPath(import.meta.url);\n-const __dirname = path.dirname(__filename);\n+    // =====================================\n+    // EXPRESS APP SETUP\n+    // =====================================\n+    const app = express();\n+    const __filename = fileURLToPath(import.meta.url);\n+    const __dirname = path.dirname(__filename);\n \n-// =====================================\n-// MSSQL CONFIG\n-// =====================================\n-const dbConfig = {\n-    user: process.env.DB_USER || \"Beverly\",\n-    password: process.env.DB_PASSWORD || \"Bev@1234567\",\n-    server: process.env.DB_SERVER || \"localhost\",\n-    database: process.env.DB_NAME || \"EstateAccessManagementSystem\",\n-    port: parseInt(process.env.DB_PORT) || 1433,\n-    options: {\n-        encrypt: false,\n-        trustServerCertificate: true,\n-    },\n-};\n+    // =====================================\n+    // MSSQL CONFIG\n+    // =====================================\n+    const dbConfig = {\n+        user: process.env.DB_USER || \"Beverly\",\n+        password: process.env.DB_PASSWORD || \"Bev@1234567\",\n+        server: process.env.DB_SERVER || \"localhost\",\n+        database: process.env.DB_NAME || \"EstateAccessManagementSystem\",\n+        port: parseInt(process.env.DB_PORT) || 1433,\n+        options: {\n+            encrypt: false,\n+            trustServerCertificate: true,\n+        },\n+    };\n \n-// =====================================\n-// GLOBAL CONNECTION POOL (PROMISE)\n-// =====================================\n-export const dbPool = new sql.ConnectionPool(dbConfig)\n-    .connect()\n-    .then(pool => {\n-        console.log(\"âœ… Connected to MSSQL\");\n-        return pool;\n-    })\n-    .catch(err => {\n-        console.error(\"âŒ MSSQL Connection Error:\", err);\n-        process.exit(1);\n-    });\n+    // =====================================\n+    // GLOBAL CONNECTION POOL (PROMISE)\n+    // =====================================\n+    export const dbPool = new sql.ConnectionPool(dbConfig)\n+        .connect()\n+        .then(pool => {\n+            console.log(\"âœ… Connected to MSSQL\");\n+            return pool;\n+        })\n+        .catch(err => {\n+            console.error(\"âŒ MSSQL Connection Error:\", err);\n+            process.exit(1);\n+        });\n \n-// =====================================\n-// MPESA CONFIG (Syntax Corrected - Default strings now have quotes)\n-// =====================================\n-// NOTE: Please ensure your .env uses MPESA_SHORTCODE, MPESA_PASSKEY, etc.\n-export const SHORTCODE = process.env.MPESA_SHORTCODE || \"174379\";\n-export const PASSKEY = process.env.MPESA_PASSKEY || \"bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919\";\n-export const CONSUMER_KEY = process.env.MPESA_CONSUMER_KEY || \"kmOLZ06AIGR4EtIovle2fwsLQU51YbWjdnSG516peEqwADAG\";\n-export const CONSUMER_SECRET = process.env.MPESA_CONSUMER_SECRET || \"i3JqaV9P75jf5Uz60jhG2R4Ph4Ix9DJs2DbM8UvfCHIjfu2BOmO5i1UTjDeAc2Aj\";\n-export const CALLBACK_URL = process.env.MPESA_CALLBACK_URL || \"https://yessenia-anthropocentric-nonpersonally.ngrok-free.dev/api/residents/payment-callback\";\n+    // =====================================\n+    // MPESA CONFIG (Syntax Corrected - Default strings now have quotes)\n+    // =====================================\n+    // NOTE: Please ensure your .env uses MPESA_SHORTCODE, MPESA_PASSKEY, etc.\n+    export const SHORTCODE = process.env.MPESA_SHORTCODE || \"174379\";\n+    export const PASSKEY = process.env.MPESA_PASSKEY || \"bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919\";\n+    export const CONSUMER_KEY = process.env.MPESA_CONSUMER_KEY || \"kmOLZ06AIGR4EtIovle2fwsLQU51YbWjdnSG516peEqwADAG\";\n+    export const CONSUMER_SECRET = process.env.MPESA_CONSUMER_SECRET || \"i3JqaV9P75jf5Uz60jhG2R4Ph4Ix9DJs2DbM8UvfCHIjfu2BOmO5i1UTjDeAc2Aj\";\n+    export const CALLBACK_URL = process.env.MPESA_CALLBACK_URL || \"https://yessenia-anthropocentric-nonpersonally.ngrok-free.dev/api/residents/payment-callback\";\n \n-// =====================================\n-// GET MPESA TOKEN\n-// =====================================\n-export async function getAccessToken() {\n-    try {\n-        const auth = Buffer.from(`${CONSUMER_KEY}:${CONSUMER_SECRET}`).toString(\"base64\");\n-        const { data } = await axios.get(\n-            \"https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials\",\n-            { headers: { Authorization: `Basic ${auth}` } }\n-        );\n-        return data.access_token;\n-    } catch (err) {\n-        console.error(\"MPESA token error:\", err.response?.data || err.message);\n-        throw new Error(\"Failed to get MPESA token\");\n+    // =====================================\n+    // GET MPESA TOKEN\n+    // =====================================\n+    export async function getAccessToken() {\n+        try {\n+            const auth = Buffer.from(`${CONSUMER_KEY}:${CONSUMER_SECRET}`).toString(\"base64\");\n+            const { data } = await axios.get(\n+                \"https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials\",\n+                { headers: { Authorization: `Basic ${auth}` } }\n+            );\n+            return data.access_token;\n+        } catch (err) {\n+            console.error(\"MPESA token error:\", err.response?.data || err.message);\n+            throw new Error(\"Failed to get MPESA token\");\n+        }\n     }\n-}\n \n-// =====================================\n-// MIDDLEWARE\n-// =====================================\n-const corsOptions = {\n-    // 1. Specify the exact origin allowed (your frontend port)\n-    origin: ['http://localhost:3000', 'http://127.0.0.1:3000'], \n-    \n-    // 2. Allow credentials (important for sending cookies/JWT tokens)\n-    credentials: true,\n-    \n-    // 3. Allow all necessary methods (GET, POST, PATCH, DELETE)\n-    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],\n-    \n-    // 4. Specify allowed headers, including 'Authorization' for Bearer tokens\n-    allowedHeaders: ['Content-Type', 'Authorization'] \n-};\n+    // =====================================\n+    // MIDDLEWARE\n+    // =====================================\n+    const corsOptions = {\n+        // 1. Specify the exact origin allowed (your frontend port)\n+        origin: ['http://localhost:3000', 'http://127.0.0.1:3000'], \n+        \n+        // 2. Allow credentials (important for sending cookies/JWT tokens)\n+        credentials: true,\n+        \n+        // 3. Allow all necessary methods (GET, POST, PATCH, DELETE)\n+        methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],\n+        \n+        // 4. Specify allowed headers, including 'Authorization' for Bearer tokens\n+        allowedHeaders: ['Content-Type', 'Authorization'] \n+    };\n \n-app.use(cors(corsOptions)); // Apply CORS middleware\n+    app.use(cors(corsOptions)); // Apply CORS middleware\n \n-app.use(express.json());\n-app.use(express.static(path.join(__dirname, \"frontend\")));\n+    app.use(express.json());\n+    app.use(express.static(path.join(__dirname, \"frontend\")));\n \n-// =====================================\n-// ROUTES\n-// =====================================\n-app.use(\"/api/auth\", authRoutes);\n-app.use(\"/api/residents\", residentsRoutes);\n-app.use(\"/api/payments\", paymentsRoutes);\n+    // =====================================\n+    // ROUTES\n\\ No newline at end of file\n+    // =====================================\n+    app.use(\"/api/auth\", authRoutes);\n+    app.use(\"/api/residents\", residentsRoutes);\n+    app.use(\"/api/payments\", paymentsRoutes);\n \n-// DIRECT ROUTE BINDINGS FOR RESIDENTS (if needed)\n-app.get(\"/api/residents/membership\", verifyToken, getMembershipRequests);\n-app.get(\"/api/residents/approved\", verifyToken, getApprovedResidents);\n-app.get(\"/api/residents/visitorsaccess\", verifyToken, getVisitorPasses);\n-app.post(\"/api/residents/pay\", verifyToken, payController);\n-app.get(\"/api/residents/payment-status\", verifyToken, getPaymentStatusController);\n+    // DIRECT ROUTE BINDINGS FOR RESIDENTS (if needed)\n+    app.get(\"/api/residents/membership\", verifyToken, getMembershipRequests);\n+    app.get(\"/api/residents/approved\", verifyToken, getApprovedResidents);\n+    app.get(\"/api/residents/visitorsaccess\", verifyToken, getVisitorPasses);\n+    app.post(\"/api/residents/pay\", verifyToken, payController);\n+    app.get(\"/api/residents/payment-status\", verifyToken, getPaymentStatusController);\n \n-// CRITICAL ADMIN ROUTES\n-// FIX: Adds the missing route definition for the admin dashboard to fetch all membership requests\n-app.get('/api/admin/memberships', verifyToken, getMembershipRequests); \n-// NOTE: Assuming getMembershipRequests fetches ALL requests (Pending/Approved/Rejected)\n-// The frontend handles filtering for \"Requests\" vs \"Records\"\n+    // CRITICAL ADMIN ROUTES\n+    // FIX: Adds the missing route definition for the admin dashboard to fetch all membership requests\n+    app.get('/api/admin/memberships', verifyToken, getMembershipRequests); \n+    // NOTE: Assuming getMembershipRequests fetches ALL requests (Pending/Approved/Rejected)\n+    // The frontend handles filtering for \"Requests\" vs \"Records\"\n \n-// Assuming you also need a route for approving a resident request:\n-// This endpoint is used by the frontend when clicking the \"Approve\" button\n-// app.post('/api/admin/approveResident', verifyToken, approveResidentController); \n+    // Assuming you also need a route for approving a resident request:\n+    // This endpoint is used by the frontend when clicking the \"Approve\" button\n+    // app.post('/api/admin/approveResident', verifyToken, approveResidentController); \n \n \n-// =====================================\n-// MPESA CALLBACK (Updated logic for M-Pesa standard structure)\n-// =====================================\n-app.post(\"/api/residents/payment-callback\", async (req, res) => {\n-    try {\n-        // M-Pesa callback data is usually nested deep\n-        const callbackData = req.body.Body?.stkCallback;\n-        if (!callbackData) {\n-            console.warn(\"Received invalid M-Pesa callback body:\", req.body);\n-            return res.status(400).send(\"Invalid callback data structure\");\n-        }\n+    // =====================================\n+    // MPESA CALLBACK (Updated logic for M-Pesa standard structure)\n+    // =====================================\n+    app.post(\"/api/residents/payment-callback\", async (req, res) => {\n+        try {\n+            // M-Pesa callback data is usually nested deep\n+            const callbackData = req.body.Body?.stkCallback;\n+            if (!callbackData) {\n+                console.warn(\"Received invalid M-Pesa callback body:\", req.body);\n+                return res.status(400).send(\"Invalid callback data structure\");\n+            }\n \n-        const resultCode = callbackData.ResultCode;\n-        const checkoutRequestID = callbackData.CheckoutRequestID;\n-        const metadata = callbackData.CallbackMetadata?.Item;\n-        \n-        let mpesaReceiptNumber = null;\n-        let phoneNumber = null;\n+            const resultCode = callbackData.ResultCode;\n+            const checkoutRequestID = callbackData.CheckoutRequestID;\n+            const metadata = callbackData.CallbackMetadata?.Item;\n+            \n+            let mpesaReceiptNumber = null;\n+            let phoneNumber = null;\n \n-        if (resultCode === 0 && metadata) {\n-            // Success: Extract essential details\n-            mpesaReceiptNumber = metadata.find(item => item.Name === 'MpesaReceiptNumber')?.Value;\n-            phoneNumber = metadata.find(item => item.Name === 'PhoneNumber')?.Value;\n-        }\n+            if (resultCode === 0 && metadata) {\n+                // Success: Extract essential details\n+                mpesaReceiptNumber = metadata.find(item => item.Name === 'MpesaReceiptNumber')?.Value;\n+                phoneNumber = metadata.find(item => item.Name === 'PhoneNumber')?.Value;\n+            }\n \n-        // Determine status\n-        const status = resultCode === 0 ? \"Verified\" : \"Failed\";\n+            // Determine status\n+            const status = resultCode === 0 ? \"Verified\" : \"Failed\";\n \n-        // Only update if we have a way to link it back, usually CheckoutRequestID is the primary key for the pending record\n-        if (checkoutRequestID) {\n-            const pool = await dbPool;\n-            \n-            // The query should ideally link on CheckoutRequestID stored during STK push\n-            // But since the current DB schema requires updating based on phone, we'll use that (though less reliable)\n-            // A better query would use a stored CheckoutRequestID\n-            await pool.request()\n-                .input(\"PhoneNumber\", sql.VarChar(20), phoneNumber || '')\n-                .input(\"Status\", sql.VarChar(20), status)\n-                .input(\"ReceiptNumber\", sql.VarChar(50), mpesaReceiptNumber || null)\n-                .query(`\n-                    -- NOTE: Linking by PhoneNumber is risky. Linking by CheckoutRequestID is safer.\n-                    UPDATE Payments\n-                    SET Status = @Status, \n-                        VerifiedDate = GETDATE(),\n-                        MpesaReceiptNumber = @ReceiptNumber -- Assuming you add this column\n-                    WHERE PhoneNumber = @PhoneNumber AND Status = 'Pending';\n-                `);\n-        } else {\n-            console.error(\"M-Pesa Callback missing CheckoutRequestID.\");\n+            // Only update if we have a way to link it back, usually CheckoutRequestID is the primary key for the pending record\n+            if (checkoutRequestID) {\n+                const pool = await dbPool;\n+                \n+                // The query should ideally link on CheckoutRequestID stored during STK push\n+                // But since the current DB schema requires updating based on phone, we'll use that (though less reliable)\n+                // A better query would use a stored CheckoutRequestID\n+                await pool.request()\n+                    .input(\"PhoneNumber\", sql.VarChar(20), phoneNumber || '')\n+                    .input(\"Status\", sql.VarChar(20), status)\n+                    .input(\"ReceiptNumber\", sql.VarChar(50), mpesaReceiptNumber || null)\n+                    .query(`\n+                        -- NOTE: Linking by PhoneNumber is risky. Linking by CheckoutRequestID is safer.\n+                        UPDATE Payments\n+                        SET Status = @Status, \n+                            VerifiedDate = GETDATE(),\n+                            MpesaReceiptNumber = @ReceiptNumber -- Assuming you add this column\n+                        WHERE PhoneNumber = @PhoneNumber AND Status = 'Pending';\n+                    `);\n+            } else {\n+                console.error(\"M-Pesa Callback missing CheckoutRequestID.\");\n+            }\n+\n+            // Send a 200 OK response back to the M-Pesa API regardless of payment status\n+            res.status(200).send(\"C2B Callback received successfully\");\n+        } catch (err) {\n+            console.error(\"Payment callback error:\", err);\n+            // Do NOT send a 500 status to M-Pesa, as it may retry indefinitely. Send 200.\n+            res.status(200).send(\"Internal processing error\");\n         }\n+    });\n \n-        // Send a 200 OK response back to the M-Pesa API regardless of payment status\n-        res.status(200).send(\"C2B Callback received successfully\");\n-    } catch (err) {\n-        console.error(\"Payment callback error:\", err);\n-        // Do NOT send a 500 status to M-Pesa, as it may retry indefinitely. Send 200.\n-        res.status(200).send(\"Internal processing error\");\n-    }\n-});\n+    // =====================================\n+    // HEALTH CHECK\n+    // =====================================\n+    app.get(\"/health\", (req, res) => \n+        res.json({ status: \"ok\", ts: new Date() })\n+    );\n \n-// =====================================\n-// HEALTH CHECK\n-// =====================================\n-app.get(\"/health\", (req, res) => \n-    res.json({ status: \"ok\", ts: new Date() })\n-);\n+    // =====================================\n+    // CRITICAL FIX â€” START SERVER ONLY AFTER DB CONNECTION\n+    // =====================================\n+    async function startServer() {\n+        try {\n+            await dbPool; // wait for DB connection to resolve\n \n-// =====================================\n-// CRITICAL FIX â€” START SERVER ONLY AFTER DB CONNECTION\n-// =====================================\n-async function startServer() {\n-    try {\n-        await dbPool; // wait for DB connection to resolve\n+            console.log(\"Starting Express server...\");\n+            const PORT = process.env.PORT || 4050;\n \n-        console.log(\"Starting Express server...\");\n-        const PORT = process.env.PORT || 4050;\n+            app.listen(PORT, () => \n+                console.log(`ðŸš€ Server running on port ${PORT}`)\n+            );\n \n-        app.listen(PORT, () => \n-            console.log(`ðŸš€ Server running on port ${PORT}`)\n-        );\n-\n-    } catch (error) {\n-        console.error(\"âŒ Failed to start server:\", error.message);\n-        process.exit(1);\n+        } catch (error) {\n+            console.error(\"âŒ Failed to start server:\", error.message);\n+            process.exit(1);\n+        }\n     }\n-}\n \n-startServer();\n+    startServer();\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763701160234,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,279 @@\n+// =====================================\n+// LOAD ENVIRONMENT VARIABLES\n+// =====================================\n+import dotenv from \"dotenv\";\n+dotenv.config();\n+\n+// =====================================\n+// IMPORTS\n+// =====================================\n+import express from \"express\";\n+import cors from \"cors\";\n+import path from \"path\";\n+import { fileURLToPath } from \"url\";\n+import sql from \"mssql\";\n+import axios from \"axios\";\n+\n+// Import routes\n+import authRoutes from \"./routes/authRoutes.js\";\n+import residentsRoutes from \"./routes/residentsRoutes.js\";\n+// Middleware\n+import { authenticateJWT } from \"./middleware/authMiddleware.js\";\n+import membershipRoutes from \"./routes/membershipRoutes.js\";\n+// Controllers (for optional direct bindings)\n+import { \n+    getMembershipRequests, // Used for both resident and admin membership listing\n+    getApprovedResidents, \n+    getVisitorPasses,\n+    payController,\n+    getPaymentStatusController,\n+    approveResidentController // Assuming you have an approve controller\n+} from \"./controllers/residentsController.js\";\n+import paymentsRoutes from \"./routes/paymentRoutes.js\";\n+import dashboardRouter from \"./routes/dashboard.js\";\n+// =====================================\n+// EXPRESS APP SETUP\n+// =====================================\n+const app = express();\n+const __filename = fileURLToPath(import.meta.url);\n+const __dirname = path.dirname(__filename);\n+\n+// =====================================\n+// MSSQL CONFIG\n+// =====================================\n+const dbConfig = {\n+    user: process.env.DB_USER || \"Beverly\",\n+    password: process.env.DB_PASSWORD || \"Bev@1234567\",\n+    server: process.env.DB_SERVER || \"localhost\",\n+    database: process.env.DB_NAME || \"EstateAccessManagementSystem\",\n+    port: parseInt(process.env.DB_PORT) || 1433,\n+    options: {\n+        encrypt: false,\n+        trustServerCertificate: true,\n+    },\n+};\n+\n+// =====================================\n+// GLOBAL CONNECTION POOL (PROMISE)\n+// =====================================\n+export const dbPool = new sql.ConnectionPool(dbConfig)\n+    .connect()\n+    .then(pool => {\n+        console.log(\"âœ… Connected to MSSQL\");\n+        return pool;\n+    })\n+    .catch(err => {\n+        console.error(\"âŒ MSSQL Connection Error:\", err);\n+        process.exit(1);\n+    });\n+\n+// =====================================\n+// MPESA CONFIG (Syntax Corrected - Default strings now have quotes)\n+// =====================================\n+// NOTE: Please ensure your .env uses MPESA_SHORTCODE, MPESA_PASSKEY, etc.\n+export const SHORTCODE = process.env.MPESA_SHORTCODE || \"174379\";\n+export const PASSKEY = process.env.MPESA_PASSKEY || \"bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919\";\n+export const CONSUMER_KEY = process.env.MPESA_CONSUMER_KEY || \"kmOLZ06AIGR4EtIovle2fwsLQU51YbWjdnSG516peEqwADAG\";\n+export const CONSUMER_SECRET = process.env.MPESA_CONSUMER_SECRET || \"i3JqaV9P75jf5Uz60jhG2R4Ph4Ix9DJs2DbM8UvfCHIjfu2BOmO5i1UTjDeAc2Aj\";\n+export const CALLBACK_URL = process.env.MPESA_CALLBACK_URL || \"https://yessenia-anthropocentric-nonpersonally.ngrok-free.dev/api/residents/payment-callback\";\n+\n+// =====================================\n+// GET MPESA TOKEN\n+// =====================================\n+export async function getAccessToken() {\n+    try {\n+        const auth = Buffer.from(`${CONSUMER_KEY}:${CONSUMER_SECRET}`).toString(\"base64\");\n+        const { data } = await axios.get(\n+            \"https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials\",\n+            { headers: { Authorization: `Basic ${auth}` } }\n+        );\n+        return data.access_token;\n+    } catch (err) {\n+        console.error(\"MPESA token error:\", err.response?.data || err.message);\n+        throw new Error(\"Failed to get MPESA token\");\n+    }\n+}\n+\n+// =====================================\n+// MIDDLEWARE\n+// =====================================\n+const corsOptions = {\n+    // 1. Specify the exact origin allowed (your frontend port)\n+    origin: ['http://localhost:3000', 'http://127.0.0.1:3000'], \n+    \n+    // 2. Allow credentials (important for sending cookies/JWT tokens)\n+    credentials: true,\n+    \n+    // 3. Allow all necessary methods (GET, POST, PATCH, DELETE)\n+    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],\n+    \n+    // 4. Specify allowed headers, including 'Authorization' for Bearer tokens\n+    allowedHeaders: ['Content-Type', 'Authorization'] \n+};\n+\n+app.use(cors(corsOptions)); // Apply CORS middleware\n+\n+app.use(express.json());\n+app.use(express.static(path.join(__dirname, \"frontend\")));\n+\n+// =====================================\n+// ROUTES\n+// =====================================\n+app.use(\"/api/auth\", authRoutes);\n+app.use(\"/api/residents\", residentsRoutes);\n+app.use(\"/api/payments\", paymentsRoutes);\n+app.use(\"/api/dashboard\", dashboardRouter);\n+app.use(\"/api/memberships\", membershipRoutes);\n+// DIRECT ROUTE BINDINGS FOR RESIDENTS (if needed)\n+app.get(\"/api/residents/membership\", authenticateJWT, getMembershipRequests);\n+app.get(\"/api/residents/approved\", authenticateJWT, getApprovedResidents);\n+app.get(\"/api/residents/visitorsaccess\", authenticateJWT, getVisitorPasses);\n+app.post(\"/api/residents/pay\", authenticateJWT, payController);\n+app.get(\"/api/residents/payment-status\", authenticateJWT, getPaymentStatusController);\n+\n+\n+// =========================================================================\n+// âœ… ADMIN DASHBOARD ROUTES FIX (Addresses all four 404 errors)\n+// =========================================================================\n+\n+// 1. GET http://localhost:3000/api/dashboard/summary (404 FIX)\n+app.get(\"/api/dashboard/summary\", authenticateJWT, async (req, res) => {\n+    try {\n+        const pool = await dbPool;\n+        // Example: Fetch counts of key entities\n+        const summaryResult = await pool.request().query(`\n+            SELECT\n+                (SELECT COUNT(*) FROM Residents WHERE Status = 'Approved') as ApprovedResidents,\n+                (SELECT COUNT(*) FROM MembershipRequests WHERE Status = 'Pending') as PendingRequests,\n+                (SELECT COUNT(*) FROM VisitorPasses WHERE IssuedAt > DATEADD(day, -7, GETDATE())) as WeeklyVisitors;\n+        `);\n+        \n+        res.status(200).json(summaryResult.recordset[0]);\n+    } catch (err) {\n+        console.error(\"Error fetching dashboard summary:\", err);\n+        res.status(500).json({ message: \"Failed to fetch dashboard summary.\" });\n+    }\n+});\n+\n+// 2. GET http://localhost:3000/api/memberships/records (404 FIX)\n+app.get(\"/api/memberships/records\", authenticateJWT, getApprovedResidents); \n+// Assumption: getApprovedResidents returns the list of approved members (the \"records\")\n+// If getApprovedResidents only returns the approved list, this handles the route.\n+\n+// 3. GET http://localhost:3000/api/access/chart (404 FIX)\n+app.get(\"/api/access/chart\", authenticateJWT, async (req, res) => {\n+    try {\n+        const pool = await dbPool;\n+        // Example: Fetch access data for charting (e.g., daily entries/passes)\n+        const chartDataResult = await pool.request().query(`\n+            SELECT TOP 7 \n+                CAST(IssuedAt AS DATE) as Date, \n+                COUNT(*) as TotalPasses \n+            FROM VisitorPasses \n+            GROUP BY CAST(IssuedAt AS DATE)\n+            ORDER BY Date DESC;\n+        `);\n+        \n+        res.status(200).json(chartDataResult.recordset);\n+    } catch (err) {\n+        console.error(\"Error fetching chart data:\", err);\n+        res.status(500).json({ message: \"Failed to fetch chart data.\" });\n+    }\n+});\n+\n+// 4. GET http://localhost:3000/api/memberships/requests (404 FIX)\n+app.get(\"/api/memberships/requests\", authenticateJWT, getMembershipRequests);\n+// Assumption: getMembershipRequests returns ALL requests, including pending ones (the \"requests\").\n+\n+// CRITICAL ADMIN ROUTE EXAMPLE (Already defined in your original code but kept for context)\n+app.get('/api/admin/memberships', authenticateJWT, getMembershipRequests); \n+\n+\n+// =====================================\n+// MPESA CALLBACK (Updated logic for M-Pesa standard structure)\n+// =====================================\n+app.post(\"/api/residents/payment-callback\", async (req, res) => {\n+    try {\n+        // M-Pesa callback data is usually nested deep\n+        const callbackData = req.body.Body?.stkCallback;\n+        if (!callbackData) {\n+            console.warn(\"Received invalid M-Pesa callback body:\", req.body);\n+            return res.status(400).send(\"Invalid callback data structure\");\n+        }\n+\n+        const resultCode = callbackData.ResultCode;\n+        const checkoutRequestID = callbackData.CheckoutRequestID;\n+        const metadata = callbackData.CallbackMetadata?.Item;\n+        \n+        let mpesaReceiptNumber = null;\n+        let phoneNumber = null;\n+\n+        if (resultCode === 0 && metadata) {\n+            // Success: Extract essential details\n+            mpesaReceiptNumber = metadata.find(item => item.Name === 'MpesaReceiptNumber')?.Value;\n+            phoneNumber = metadata.find(item => item.Name === 'PhoneNumber')?.Value;\n+        }\n+\n+        // Determine status\n+        const status = resultCode === 0 ? \"Verified\" : \"Failed\";\n+\n+        // Only update if we have a way to link it back, usually CheckoutRequestID is the primary key for the pending record\n+        if (checkoutRequestID) {\n+            const pool = await dbPool;\n+            \n+            // The query should ideally link on CheckoutRequestID stored during STK push\n+            // But since the current DB schema requires updating based on phone, we'll use that (though less reliable)\n+            // A better query would use a stored CheckoutRequestID\n+            await pool.request()\n+                .input(\"PhoneNumber\", sql.VarChar(20), phoneNumber || '')\n+                .input(\"Status\", sql.VarChar(20), status)\n+                .input(\"ReceiptNumber\", sql.VarChar(50), mpesaReceiptNumber || null)\n+                .query(`\n+                    -- NOTE: Linking by PhoneNumber is risky. Linking by CheckoutRequestID is safer.\n+                    UPDATE Payments\n+                    SET Status = @Status, \n+                        VerifiedDate = GETDATE(),\n+                        MpesaReceiptNumber = @ReceiptNumber -- Assuming you add this column\n+                    WHERE PhoneNumber = @PhoneNumber AND Status = 'Pending';\n+                `);\n+        } else {\n+            console.error(\"M-Pesa Callback missing CheckoutRequestID.\");\n+        }\n+\n+        // Send a 200 OK response back to the M-Pesa API regardless of payment status\n+        res.status(200).send(\"C2B Callback received successfully\");\n+    } catch (err) {\n+        console.error(\"Payment callback error:\", err);\n+        // Do NOT send a 500 status to M-Pesa, as it may retry indefinitely. Send 200.\n+        res.status(200).send(\"Internal processing error\");\n+    }\n+});\n+\n+// =====================================\n+// HEALTH CHECK\n+// =====================================\n+app.get(\"/health\", (req, res) => \n+    res.json({ status: \"ok\", ts: new Date() })\n+);\n+\n+// =====================================\n+// CRITICAL FIX â€” START SERVER ONLY AFTER DB CONNECTION\n+// =====================================\n+async function startServer() {\n+    try {\n+        await dbPool; // wait for DB connection to resolve\n+\n+        console.log(\"Starting Express server...\");\n+        const PORT = process.env.PORT || 4050;\n+\n+        app.listen(PORT, () => \n+            console.log(`ðŸš€ Server running on port ${PORT}`)\n+        );\n+\n+    } catch (error) {\n+        console.error(\"âŒ Failed to start server:\", error.message);\n+        process.exit(1);\n+    }\n+}\n+\n+startServer();\n\\ No newline at end of file\n"
                }
            ],
            "date": 1763619285298,
            "name": "Commit-0",
            "content": "// =====================================\n// LOAD ENVIRONMENT VARIABLES\n// =====================================\nimport dotenv from \"dotenv\";\ndotenv.config();\n\n// =====================================\n// IMPORTS\n// =====================================\nimport express from \"express\";\nimport cors from \"cors\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport sql from \"mssql\";\nimport axios from \"axios\";\n\n// Import routes\nimport authRoutes from \"./routes/authRoutes.js\";\nimport residentsRoutes from \"./routes/residentsRoutes.js\";\n// Middleware\nimport { verifyToken } from \"./middleware/authMiddleware.js\";\n\n// Controllers (for optional direct bindings)\nimport { \n    getMembershipRequests, \n    getApprovedResidents, \n    getVisitorPasses,\n    payController,\n    getPaymentStatusController\n} from \"./controllers/residentsController.js\";\n\n// =====================================\n// EXPRESS APP SETUP\n// =====================================\nconst app = express();\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// =====================================\n// MSSQL CONFIG\n// =====================================\nconst dbConfig = {\n    user: process.env.DB_USER || \"Beverly\",\n    password: process.env.DB_PASSWORD || \"Bev@1234567\",\n    server: process.env.DB_SERVER || \"localhost\",\n    database: process.env.DB_NAME || \"EstateAccessManagementSystem\",\n    port: parseInt(process.env.DB_PORT) || 1433,\n    options: {\n        encrypt: false,\n        trustServerCertificate: true,\n    },\n};\n\n// =====================================\n// GLOBAL CONNECTION POOL (PROMISE)\n// =====================================\nexport const dbPool = new sql.ConnectionPool(dbConfig)\n    .connect()\n    .then(pool => {\n        console.log(\"âœ… Connected to MSSQL\");\n        return pool;\n    })\n    .catch(err => {\n        console.error(\"âŒ MSSQL Connection Error:\", err);\n        process.exit(1);\n    });\n\n// =====================================\n// MPESA CONFIG\n// =====================================\nexport const SHORTCODE = process.env.MPESA_SHORTCODE;\nexport const PASSKEY = process.env.MPESA_PASSKEY;\nexport const CONSUMER_KEY = process.env.MPESA_CONSUMER_KEY;\nexport const CONSUMER_SECRET = process.env.MPESA_CONSUMER_SECRET;\nexport const CALLBACK_URL = process.env.MPESA_CALLBACK_URL;\n\n// =====================================\n// GET MPESA TOKEN\n// =====================================\nexport async function getAccessToken() {\n    try {\n        const auth = Buffer.from(`${CONSUMER_KEY}:${CONSUMER_SECRET}`).toString(\"base64\");\n        const { data } = await axios.get(\n            \"https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials\",\n            { headers: { Authorization: `Basic ${auth}` } }\n        );\n        return data.access_token;\n    } catch (err) {\n        console.error(\"MPESA token error:\", err.response?.data || err.message);\n        throw new Error(\"Failed to get MPESA token\");\n    }\n}\n\n// =====================================\n// MIDDLEWARE\n// =====================================\napp.use(cors({\n    origin: ['http://localhost:3000', 'http://127.0.0.1:3000'],\n    credentials: true,\n    methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    allowedHeaders: [\"Content-Type\", \"Authorization\"]\n}));\n\napp.use(express.json());\napp.use(express.static(path.join(__dirname, \"frontend\")));\n\n// =====================================\n// ROUTES\n// =====================================\napp.use(\"/api/auth\", authRoutes);\napp.use(\"/api/residents\", residentsRoutes);\n\n// DIRECT ROUTE BINDINGS FOR CONTROLLERS (if needed)\napp.get(\"/api/residents/membership\", verifyToken, getMembershipRequests);\napp.get(\"/api/residents/approved\", verifyToken, getApprovedResidents);\napp.get(\"/api/residents/visitorsaccess\", verifyToken, getVisitorPasses);\napp.post(\"/api/residents/pay\", verifyToken, payController);\napp.get(\"/api/residents/payment-status\", verifyToken, getPaymentStatusController);\n\n// =====================================\n// MPESA CALLBACK\n// =====================================\napp.post(\"/api/residents/payment-callback\", async (req, res) => {\n    try {\n        const pool = await dbPool;\n        const { phone, resultCode } = req.body;\n        if (!phone) return res.status(400).send(\"Phone required\");\n        const status = resultCode === 0 ? \"Verified\" : \"failed\";\n        await pool.request()\n            .input(\"PhoneNumber\", sql.VarChar(20), phone)\n            .input(\"Status\", sql.VarChar(20), status)\n            .query(`\n                UPDATE Payments\n               SET Status = @Status, VerifiedDate = GETDATE()\n                WHERE PhoneNumber = @PhoneNumber AND Status = 'pending'\n            `);\n\n        res.status(200).send(\"OK\");\n    } catch (err) {\n        console.error(\"Payment callback error:\", err);\n        res.status(500).send(\"Error\");\n    }\n});\n\n// =====================================\n// HEALTH CHECK\n// =====================================\napp.get(\"/health\", (req, res) => \n    res.json({ status: \"ok\", ts: new Date() })\n);\n\n// =====================================\n// CRITICAL FIX â€” START SERVER ONLY AFTER DB CONNECTION\n// =====================================\nasync function startServer() {\n    try {\n        await dbPool; // wait for DB\n\n        console.log(\"Starting Express server...\");\n        const PORT = process.env.PORT || 4050;\n\n        app.listen(PORT, () => \n            console.log(`ðŸš€ Server running on port ${PORT}`)\n        );\n\n    } catch (error) {\n        console.error(\"âŒ Failed to start server:\", error.message);\n        process.exit(1);\n    }\n}\n\nstartServer();\n// ----------------------------------------------------\n// ðŸŸ¢ CORS CONFIGURATION (The Fix)\n// ----------------------------------------------------\n\nconst corsOptions = {\n    // 1. Specify the exact origin allowed (your frontend port)\n    origin: 'http://localhost:3000', \n    \n    // 2. Allow credentials (important for sending cookies/JWT tokens)\n    credentials: true,\n    \n    // 3. Allow all necessary methods (GET, POST, PATCH, DELETE)\n    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],\n    \n    // 4. Specify allowed headers, including 'Authorization' for Bearer tokens\n    allowedHeaders: ['Content-Type', 'Authorization'] \n};\n\napp.use(cors(corsOptions)); // Apply CORS middleware\n\n// ----------------------------------------------------\n\n// ... app.use(express.json());\n// ... app.use('/api/membership', membershipRoutes);\n// ... Start server on port 4050"
        }
    ]
}