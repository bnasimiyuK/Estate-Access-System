{
    "sourceFile": "backend/controllers/paymentsController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 16,
            "patches": [
                {
                    "date": 1763620136789,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1763620188478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,14 @@\n   const role = req.user?.role?.toLowerCase() || \"\";\n   const residentId = req.user?.ResidentID ?? null;\n   return { role, residentId };\n };\n-\n+async function executeQuery(query, inputs = []) {\n+    const pool = await dbPool;\n+    const request = pool.request();\n+    inputs.forEach(input => request.input(input.name, input.type, input.value));\n+    return request.query(query);\n+}\n // ================= GET ALL PAYMENTS =================\n export const getPayments = async (req, res) => {\n   const { role, residentId } = getIdentityFromReq(req);\n \n"
                },
                {
                    "date": 1763620400549,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,9 +108,9 @@\n \n // ================= MAKE PAYMENT =================\n export const makePayment = async (req, res) => {\n   const { role, residentId: authResidentId } = getIdentityFromReq(req);\n-  const { residentId, amount, paymentMethod, reference } = req.body;\n+  const { residentId, amount, paymentMethod, reference, phone } = req.body;\n \n   if (role === \"resident\" && residentId !== authResidentId) {\n     return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n   }\n"
                },
                {
                    "date": 1763620660131,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,161 +1,230 @@\n-// backend/controllers/paymentsController.js\n+// backend/controllers/paymentsController.js - COMPLETE CORRECTED & UNIFIED CODE\n+\n import sql from \"mssql\";\n-import dbConfig from \"../config/dbConfig.js\";\n-import {dbpool} from \"../server.js\";\n+// UNIFIED IMPORT: Use dbPool exported from server.js\n+import { dbPool } from \"../server.js\"; \n+// NOTE: dbConfig import removed as we use dbPool directly\n+\n // Helper: get identity from JWT\n const getIdentityFromReq = (req) => {\n-  const role = req.user?.role?.toLowerCase() || \"\";\n-  const residentId = req.user?.ResidentID ?? null;\n-  return { role, residentId };\n+    const role = req.user?.role?.toLowerCase() || \"\";\n+    // Ensure ResidentID is treated as a Number/Int if that's its database type\n+    const residentId = req.user?.ResidentID ? parseInt(req.user.ResidentID, 10) : null; \n+    const verifierID = req.user?.UserID || req.user?.NationalID || 'ADMIN';\n+    return { role, residentId, verifierID };\n };\n+\n+// Helper to execute a query using the central dbPool\n async function executeQuery(query, inputs = []) {\n     const pool = await dbPool;\n     const request = pool.request();\n     inputs.forEach(input => request.input(input.name, input.type, input.value));\n     return request.query(query);\n }\n-// ================= GET ALL PAYMENTS =================\n+\n+// ----------------------------------------------------------------------\n+// ================= GET ALL PAYMENTS (Updated to use executeQuery) =================\n+// ----------------------------------------------------------------------\n export const getPayments = async (req, res) => {\n-  const { role, residentId } = getIdentityFromReq(req);\n+    const { role, residentId } = getIdentityFromReq(req);\n \n-  try {\n-    const pool = await sql.connect(dbConfig);\n+    try {\n+        let query = `\n+            SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod, PhoneNumber\n+            FROM Payments\n+            ORDER BY PaymentDate DESC\n+        `;\n \n-    let query = `\n-      SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod\n-      FROM Payments\n-    `;\n+        const inputs = [];\n+        if (role === \"resident\") {\n+            query = `\n+                SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod, PhoneNumber\n+                FROM Payments\n+                WHERE ResidentID = @ResidentID\n+                ORDER BY PaymentDate DESC\n+            `;\n+            inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n+        }\n \n-    const request = pool.request();\n-    if (role === \"resident\") {\n-      query += \" WHERE ResidentID = @ResidentID\";\n-      request.input(\"ResidentID\", sql.VarChar, residentId);\n+        const result = await executeQuery(query, inputs);\n+        res.json(result.recordset);\n+\n+    } catch (err) {\n+        console.error(\"Error fetching payments:\", err);\n+        res.status(500).json({ message: \"Error fetching payments\" });\n     }\n-\n-    const result = await request.query(query);\n-    res.json(result.recordset);\n-\n-  } catch (err) {\n-    console.error(\"Error fetching payments:\", err);\n-    res.status(500).json({ message: \"Error fetching payments\" });\n-  }\n };\n \n-// ================= GET VERIFIED PAYMENTS =================\n+// ----------------------------------------------------------------------\n+// ================= GET VERIFIED PAYMENTS (Updated to use executeQuery) =================\n+// ----------------------------------------------------------------------\n export const getVerifiedPayments = async (req, res) => {\n-  const { role, residentId } = getIdentityFromReq(req);\n+    const { role, residentId } = getIdentityFromReq(req);\n \n-  try {\n-    const pool = await sql.connect(dbConfig);\n+    try {\n+        let query = `\n+            SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod, PhoneNumber\n+            FROM Payments\n+            WHERE Status='Verified'\n+            ORDER BY PaymentDate DESC\n+        `;\n \n-    let query = `\n-      SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod\n-      FROM Payments\n-      WHERE Status='Verified'\n-    `;\n+        const inputs = [];\n+        if (role === \"resident\") {\n+            query = `\n+                SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod, PhoneNumber\n+                FROM Payments\n+                WHERE Status='Verified' AND ResidentID = @ResidentID\n+                ORDER BY PaymentDate DESC\n+            `;\n+            inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n+        }\n \n-    const request = pool.request();\n-    if (role === \"resident\") {\n-      query += \" AND ResidentID = @ResidentID\";\n-      request.input(\"ResidentID\", sql.VarChar, residentId);\n+        const result = await executeQuery(query, inputs);\n+        res.json(result.recordset);\n+\n+    } catch (err) {\n+        console.error(\"Error fetching verified payments:\", err);\n+        res.status(500).json({ message: \"Error fetching verified payments\" });\n     }\n-\n-    const result = await request.query(query);\n-    res.json(result.recordset);\n-\n-  } catch (err) {\n-    console.error(\"Error fetching verified payments:\", err);\n-    res.status(500).json({ message: \"Error fetching verified payments\" });\n-  }\n };\n \n-// ================= GET BALANCES =================\n+// ----------------------------------------------------------------------\n+// ================= GET BALANCES (Updated to use executeQuery) =================\n+// ----------------------------------------------------------------------\n export const getBalances = async (req, res) => {\n-  const { role, residentId } = getIdentityFromReq(req);\n+    const { role, residentId } = getIdentityFromReq(req);\n \n-  try {\n-    const pool = await sql.connect(dbConfig);\n+    try {\n+        let query = `\n+            SELECT \n+                r.ResidentID,\n+                r.ResidentName,\n+                ISNULL(SUM(p.Amount), 0) AS TotalPaid,\n+                ISNULL(r.TotalDue, 0) AS TotalDue,\n+                (ISNULL(r.TotalDue,0) - ISNULL(SUM(p.Amount),0)) AS Balance\n+            FROM Residents r\n+            LEFT JOIN Payments p\n+                ON r.ResidentID = p.ResidentID AND p.Status='Verified'\n+        `;\n \n-    let query = `\n-      SELECT \n-        r.ResidentID,\n-        r.ResidentName,\n-        ISNULL(SUM(p.Amount), 0) AS TotalPaid,\n-        ISNULL(r.TotalDue, 0) AS TotalDue,\n-        (ISNULL(r.TotalDue,0) - ISNULL(SUM(p.Amount),0)) AS Balance\n-      FROM Residents r\n-      LEFT JOIN Payments p\n-        ON r.ResidentID = p.ResidentID AND p.Status='Verified'\n-    `;\n+        const inputs = [];\n+        if (role === \"resident\") {\n+            query += \" WHERE r.ResidentID = @ResidentID\";\n+            inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n+        }\n \n-    if (role === \"resident\") {\n-      query += \" WHERE r.ResidentID = @ResidentID\";\n-    }\n+        query += \" GROUP BY r.ResidentID, r.ResidentName, r.TotalDue\";\n \n-    query += \" GROUP BY r.ResidentID, r.ResidentName, r.TotalDue\";\n+        const result = await executeQuery(query, inputs);\n+        res.json(result.recordset);\n \n-    const request = pool.request();\n-    if (role === \"resident\") request.input(\"ResidentID\", sql.VarChar, residentId);\n-\n-    const result = await request.query(query);\n-    res.json(result.recordset);\n-\n-  } catch (err) {\n-    console.error(\"Error fetching balances:\", err);\n-    res.status(500).json({ message: \"Error fetching balances\" });\n-  }\n+    } catch (err) {\n+        console.error(\"Error fetching balances:\", err);\n+        res.status(500).json({ message: \"Error fetching balances\" });\n+    }\n };\n \n-// ================= MAKE PAYMENT =================\n+// ----------------------------------------------------------------------\n+// ================= MAKE PAYMENT (UNIFIED & CORRECTED) =================\n+// ----------------------------------------------------------------------\n export const makePayment = async (req, res) => {\n-  const { role, residentId: authResidentId } = getIdentityFromReq(req);\n-  const { residentId, amount, paymentMethod, reference, phone } = req.body;\n+    const { role, residentId: authResidentId } = getIdentityFromReq(req);\n+    const { residentId, amount, paymentMethod, reference, phone } = req.body;\n \n-  if (role === \"resident\" && residentId !== authResidentId) {\n-    return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n-  }\n+    // Authorization Check: Prevent residents from paying for others\n+    if (role === \"resident\" && parseInt(residentId, 10) !== authResidentId) {\n+        return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n+    }\n+    \n+    // Data Validation\n+    if (!residentId || !amount || !paymentMethod || !phone) {\n+        return res.status(400).json({ message: \"Missing required fields (residentId, amount, paymentMethod, phone).\" });\n+    }\n \n-  try {\n-    const pool = await sql.connect(dbConfig);\n-    await pool.request()\n-      .input(\"ResidentID\", sql.VarChar, residentId)\n-      .input(\"Amount\", sql.Decimal(10,2), amount)\n-      .input(\"PaymentMethod\", sql.VarChar, paymentMethod)\n-      .input(\"Reference\", sql.VarChar, reference)\n-      .input(\"Status\", sql.VarChar, \"Pending\")\n-      .query(`\n-        INSERT INTO Payments \n-        (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate)\n-        VALUES (@ResidentID, @Amount, @PaymentMethod, @Reference, @Status, GETDATE())\n-      `);\n+    try {\n+        const query = `\n+            INSERT INTO Payments \n+            (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate, PhoneNumber)\n+            OUTPUT INSERTED.PaymentID\n+            VALUES (@ResidentID, @Amount, @PaymentMethod, @Reference, 'Pending', GETDATE(), @PhoneNumber);\n+        `;\n+        \n+        const inputs = [\n+            { name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) },\n+            { name: \"Amount\", type: sql.Decimal(10, 2), value: amount },\n+            { name: \"PaymentMethod\", type: sql.VarChar(50), value: paymentMethod },\n+            { name: \"Reference\", type: sql.VarChar(100), value: reference || 'N/A' },\n+            { name: \"PhoneNumber\", type: sql.VarChar(20), value: phone },\n+        ];\n+        \n+        const result = await executeQuery(query, inputs);\n+        const newPaymentId = result.recordset[0]?.PaymentID;\n \n-    res.json({ message: \"Payment submitted successfully\" });\n+        res.status(201).json({ \n+            message: \"Payment submitted successfully. Awaiting M-Pesa verification.\",\n+            paymentId: newPaymentId\n+        });\n \n-  } catch (err) {\n-    console.error(\"Error submitting payment:\", err);\n-    res.status(500).json({ message: \"Error submitting payment\" });\n-  }\n+    } catch (err) {\n+        console.error(\"Error submitting payment:\", err);\n+        res.status(500).json({ message: \"Error submitting payment\", details: err.message });\n+    }\n };\n \n-// ================= VERIFY PAYMENT (ADMIN ONLY) =================\n+// ----------------------------------------------------------------------\n+// ================= VERIFY PAYMENT (ADMIN ONLY) (UNIFIED & CORRECTED) =================\n+// ----------------------------------------------------------------------\n export const verifyPayment = async (req, res) => {\n-  const { role } = getIdentityFromReq(req);\n-  const { id } = req.params;\n+    const { role, verifierID } = getIdentityFromReq(req);\n+    const { id } = req.params;\n+    const verificationDate = new Date();\n \n-  if (role !== \"admin\") {\n-    return res.status(403).json({ message: \"Unauthorized\" });\n-  }\n+    if (role !== \"admin\") {\n+        return res.status(403).json({ message: \"Unauthorized\" });\n+    }\n \n-  try {\n-    const pool = await sql.connect(dbConfig);\n-    await pool.request()\n-      .input(\"PaymentID\", sql.Int, id)\n-      .query(\"UPDATE Payments SET Status='Verified', VerifiedDate=GETDATE() WHERE PaymentID=@PaymentID\");\n+    try {\n+        if (!id) return res.status(400).json({ message: \"Payment ID missing.\" });\n \n-    res.json({ message: \"Payment verified successfully\" });\n+        const query = `\n+            UPDATE Payments \n+            SET \n+                Status = 'Verified', \n+                VerifiedBy = @VerifierID, \n+                VerifiedDate = @VerifiedDate\n+            WHERE PaymentID = @PaymentID AND Status <> 'Verified';\n+        `;\n+        \n+        const inputs = [\n+            { name: \"PaymentID\", type: sql.Int, value: id },\n+            { name: \"VerifierID\", type: sql.VarChar(50), value: verifierID.toString() },\n+            { name: \"VerifiedDate\", type: sql.DateTime, value: verificationDate },\n+        ];\n+        \n+        const result = await executeQuery(query, inputs);\n \n-  } catch (err) {\n-    console.error(\"Error verifying payment:\", err);\n-    res.status(500).json({ message: \"Error verifying payment\" });\n-  }\n+        if (result.rowsAffected[0] === 0) {\n+            // This is crucial: check if the payment was already Verified\n+            const checkQuery = await executeQuery(`SELECT Status FROM Payments WHERE PaymentID = @PaymentID`, [{ name: \"PaymentID\", type: sql.Int, value: id }]);\n+            \n+            if (checkQuery.recordset.length === 0) {\n+                 return res.status(404).json({ message: \"Payment not found.\" });\n+            }\n+\n+            return res.status(200).json({ message: `Payment ${id} was already verified or update failed.` });\n+        }\n+\n+        res.json({ message: `Payment ${id} verified successfully.` });\n+\n+    } catch (err) {\n+        console.error(\"DB Error in verifyPayment:\", err);\n+        res.status(500).json({ message: \"Failed to verify payment.\", details: err.message });\n+    }\n };\n+\n+// -------------------------------------------------------------\n+// GET LOGIC (Simplified & Consolidated)\n+// -------------------------------------------------------------\n+// NOTE: getPayments, getVerifiedPayments, and getBalances are already defined above.\n+// The executeQuery helper function is now used by all of them for a unified style.\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763621485426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -221,10 +221,37 @@\n         console.error(\"DB Error in verifyPayment:\", err);\n         res.status(500).json({ message: \"Failed to verify payment.\", details: err.message });\n     }\n };\n+// Add this to backend/controllers/paymentsController.js\n \n // -------------------------------------------------------------\n+// GET PAYMENT SUMMARY (NEW)\n+// -------------------------------------------------------------\n+export async function getPaymentSummary(req, res) {\n+    try {\n+        const pool = await dbPool;\n+        \n+        const result = await pool.request().query(`\n+            SELECT \n+                COUNT(*) AS totalPayments,\n+                SUM(CASE WHEN Status = 'Verified' THEN 1 ELSE 0 END) AS totalVerified,\n+                SUM(CASE WHEN Status = 'Pending' THEN 1 ELSE 0 END) AS totalPending\n+            FROM Payments\n+        `);\n+\n+        if (result.recordset.length === 0) {\n+             return res.json({ totalPayments: 0, totalVerified: 0, totalPending: 0 });\n+        }\n+\n+        res.json(result.recordset[0]);\n+\n+    } catch (err) {\n+        console.error(\"DB Error in getPaymentSummary:\", err);\n+        res.status(500).json({ message: \"Failed to fetch payment summary.\" });\n+    }\n+}\n+// -------------------------------------------------------------\n // GET LOGIC (Simplified & Consolidated)\n // -------------------------------------------------------------\n // NOTE: getPayments, getVerifiedPayments, and getBalances are already defined above.\n // The executeQuery helper function is now used by all of them for a unified style.\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763623056530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,22 @@\n // backend/controllers/paymentsController.js - COMPLETE CORRECTED & UNIFIED CODE\n \n import sql from \"mssql\";\n // UNIFIED IMPORT: Use dbPool exported from server.js\n+// backend/controllers/paymentsController.js\n+\n+import sql from \"mssql\";\n+import { \n+    dbPool, \n+    SHORTCODE, \n+    PASSKEY, \n+    CALLBACK_URL,\n+    getAccessToken // Import the function to get the token\n+} from \"../server.js\"; // <-- Ensure these are correctly exported in server.js\n+\n+// ... rest of the imports (like getIdentityFromReq and executeQuery helpers)\n+\n+import axios from \"axios\"; // Need axios here for the M-Pesa request\n import { dbPool } from \"../server.js\"; \n // NOTE: dbConfig import removed as we use dbPool directly\n \n // Helper: get identity from JWT\n@@ -127,8 +141,10 @@\n \n // ----------------------------------------------------------------------\n // ================= MAKE PAYMENT (UNIFIED & CORRECTED) =================\n // ----------------------------------------------------------------------\n+// backend/controllers/paymentsController.js - makePayment function\n+\n export const makePayment = async (req, res) => {\n     const { role, residentId: authResidentId } = getIdentityFromReq(req);\n     const { residentId, amount, paymentMethod, reference, phone } = req.body;\n \n@@ -141,8 +157,19 @@\n     if (!residentId || !amount || !paymentMethod || !phone) {\n         return res.status(400).json({ message: \"Missing required fields (residentId, amount, paymentMethod, phone).\" });\n     }\n \n+    // Prepare Phone Number for M-Pesa (if needed)\n+    let phoneNo = phone;\n+    if (paymentMethod.toLowerCase() === 'mpesa') {\n+        // Convert 07... or +2547... to 2547...\n+        phoneNo = phone.replace(/^0|^\\+254/g, \"254\"); \n+        if (!phoneNo.match(/^2547\\d{8}$/)) {\n+            return res.status(400).json({ message: \"Invalid M-Pesa phone number format.\" });\n+        }\n+    }\n+    \n+    // --- Step 1: Insert Pending Payment into DB ---\n     try {\n         const query = `\n             INSERT INTO Payments \n             (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate, PhoneNumber)\n@@ -154,25 +181,75 @@\n             { name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) },\n             { name: \"Amount\", type: sql.Decimal(10, 2), value: amount },\n             { name: \"PaymentMethod\", type: sql.VarChar(50), value: paymentMethod },\n             { name: \"Reference\", type: sql.VarChar(100), value: reference || 'N/A' },\n-            { name: \"PhoneNumber\", type: sql.VarChar(20), value: phone },\n+            { name: \"PhoneNumber\", type: sql.VarChar(20), value: phoneNo },\n         ];\n         \n         const result = await executeQuery(query, inputs);\n         const newPaymentId = result.recordset[0]?.PaymentID;\n \n+        // --- Step 2: M-Pesa STK Push (Only if payment method is mpesa) ---\n+        if (paymentMethod.toLowerCase() === 'mpesa') {\n+            const token = await getAccessToken();\n+            const timestamp = new Date().toISOString().replace(/[^0-9]/g, \"\").slice(0, 14);\n+            const password = Buffer.from(`${SHORTCODE}${PASSKEY}${timestamp}`).toString(\"base64\");\n+            const businessShortCode = SHORTCODE;\n+            \n+            const mpesaUrl = \"https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest\";\n+            \n+            const stkPushData = {\n+                BusinessShortCode: businessShortCode,\n+                Password: password,\n+                Timestamp: timestamp,\n+                TransactionType: \"CustomerPayBillOnline\",\n+                Amount: amount,\n+                PartyA: phoneNo,\n+                PartyB: businessShortCode,\n+                PhoneNumber: phoneNo,\n+                CallBackURL: CALLBACK_URL,\n+                AccountReference: `EstatePay-${newPaymentId}`, // Use the new ID for reference\n+                TransactionDesc: \"Estate Management Payment\",\n+            };\n+\n+            const mpesaRes = await axios.post(mpesaUrl, stkPushData, {\n+                headers: {\n+                    Authorization: `Bearer ${token}`,\n+                    'Content-Type': 'application/json',\n+                },\n+            });\n+\n+            // If M-Pesa successfully sends the prompt\n+            if (mpesaRes.data.ResponseCode === '0') {\n+                return res.status(202).json({ \n+                    message: \"M-Pesa STK Push successful. Check your phone for prompt.\",\n+                    paymentId: newPaymentId,\n+                    checkoutRequestID: mpesaRes.data.CheckoutRequestID\n+                });\n+            } else {\n+                 // Log M-Pesa error but keep the 'Pending' status in DB unless you manually update it here.\n+                 console.error(\"M-Pesa API Error:\", mpesaRes.data);\n+                 \n+                 // CRITICAL: If STK push fails, the resident won't get a prompt. You should indicate this failure to the user.\n+                 return res.status(500).json({ \n+                     message: \"Payment recorded as pending, but M-Pesa STK Push failed.\", \n+                     details: mpesaRes.data \n+                 });\n+            }\n+        }\n+        \n+        // Response for non-Mpesa payments\n         res.status(201).json({ \n-            message: \"Payment submitted successfully. Awaiting M-Pesa verification.\",\n+            message: \"Payment submitted successfully. Awaiting manual verification.\",\n             paymentId: newPaymentId\n         });\n \n     } catch (err) {\n-        console.error(\"Error submitting payment:\", err);\n-        res.status(500).json({ message: \"Error submitting payment\", details: err.message });\n+        console.error(\"Error submitting payment or M-Pesa STK Push failed:\", err.response?.data || err.message);\n+        // Handle database or network errors\n+        res.status(500).json({ message: \"Error processing payment\", details: err.response?.data?.errorMessage || err.message });\n     }\n };\n-\n // ----------------------------------------------------------------------\n // ================= VERIFY PAYMENT (ADMIN ONLY) (UNIFIED & CORRECTED) =================\n // ----------------------------------------------------------------------\n export const verifyPayment = async (req, res) => {\n"
                },
                {
                    "date": 1763623774816,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,9 +203,9 @@\n                 Timestamp: timestamp,\n                 TransactionType: \"CustomerPayBillOnline\",\n                 Amount: amount,\n                 PartyA: phoneNo,\n-                PartyB: businessShortCode,\n+                PartyB: 174379,\n                 PhoneNumber: phoneNo,\n                 CallBackURL: CALLBACK_URL,\n                 AccountReference: `EstatePay-${newPaymentId}`, // Use the new ID for reference\n                 TransactionDesc: \"Estate Management Payment\",\n"
                },
                {
                    "date": 1763623948007,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -141,10 +141,8 @@\n \n // ----------------------------------------------------------------------\n // ================= MAKE PAYMENT (UNIFIED & CORRECTED) =================\n // ----------------------------------------------------------------------\n-// backend/controllers/paymentsController.js - makePayment function\n-\n export const makePayment = async (req, res) => {\n     const { role, residentId: authResidentId } = getIdentityFromReq(req);\n     const { residentId, amount, paymentMethod, reference, phone } = req.body;\n \n@@ -157,19 +155,8 @@\n     if (!residentId || !amount || !paymentMethod || !phone) {\n         return res.status(400).json({ message: \"Missing required fields (residentId, amount, paymentMethod, phone).\" });\n     }\n \n-    // Prepare Phone Number for M-Pesa (if needed)\n-    let phoneNo = phone;\n-    if (paymentMethod.toLowerCase() === 'mpesa') {\n-        // Convert 07... or +2547... to 2547...\n-        phoneNo = phone.replace(/^0|^\\+254/g, \"254\"); \n-        if (!phoneNo.match(/^2547\\d{8}$/)) {\n-            return res.status(400).json({ message: \"Invalid M-Pesa phone number format.\" });\n-        }\n-    }\n-    \n-    // --- Step 1: Insert Pending Payment into DB ---\n     try {\n         const query = `\n             INSERT INTO Payments \n             (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate, PhoneNumber)\n@@ -181,75 +168,25 @@\n             { name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) },\n             { name: \"Amount\", type: sql.Decimal(10, 2), value: amount },\n             { name: \"PaymentMethod\", type: sql.VarChar(50), value: paymentMethod },\n             { name: \"Reference\", type: sql.VarChar(100), value: reference || 'N/A' },\n-            { name: \"PhoneNumber\", type: sql.VarChar(20), value: phoneNo },\n+            { name: \"PhoneNumber\", type: sql.VarChar(20), value: phone },\n         ];\n         \n         const result = await executeQuery(query, inputs);\n         const newPaymentId = result.recordset[0]?.PaymentID;\n \n-        // --- Step 2: M-Pesa STK Push (Only if payment method is mpesa) ---\n-        if (paymentMethod.toLowerCase() === 'mpesa') {\n-            const token = await getAccessToken();\n-            const timestamp = new Date().toISOString().replace(/[^0-9]/g, \"\").slice(0, 14);\n-            const password = Buffer.from(`${SHORTCODE}${PASSKEY}${timestamp}`).toString(\"base64\");\n-            const businessShortCode = SHORTCODE;\n-            \n-            const mpesaUrl = \"https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest\";\n-            \n-            const stkPushData = {\n-                BusinessShortCode: businessShortCode,\n-                Password: password,\n-                Timestamp: timestamp,\n-                TransactionType: \"CustomerPayBillOnline\",\n-                Amount: amount,\n-                PartyA: phoneNo,\n-                PartyB: 174379,\n-                PhoneNumber: phoneNo,\n-                CallBackURL: CALLBACK_URL,\n-                AccountReference: `EstatePay-${newPaymentId}`, // Use the new ID for reference\n-                TransactionDesc: \"Estate Management Payment\",\n-            };\n-\n-            const mpesaRes = await axios.post(mpesaUrl, stkPushData, {\n-                headers: {\n-                    Authorization: `Bearer ${token}`,\n-                    'Content-Type': 'application/json',\n-                },\n-            });\n-\n-            // If M-Pesa successfully sends the prompt\n-            if (mpesaRes.data.ResponseCode === '0') {\n-                return res.status(202).json({ \n-                    message: \"M-Pesa STK Push successful. Check your phone for prompt.\",\n-                    paymentId: newPaymentId,\n-                    checkoutRequestID: mpesaRes.data.CheckoutRequestID\n-                });\n-            } else {\n-                 // Log M-Pesa error but keep the 'Pending' status in DB unless you manually update it here.\n-                 console.error(\"M-Pesa API Error:\", mpesaRes.data);\n-                 \n-                 // CRITICAL: If STK push fails, the resident won't get a prompt. You should indicate this failure to the user.\n-                 return res.status(500).json({ \n-                     message: \"Payment recorded as pending, but M-Pesa STK Push failed.\", \n-                     details: mpesaRes.data \n-                 });\n-            }\n-        }\n-        \n-        // Response for non-Mpesa payments\n         res.status(201).json({ \n-            message: \"Payment submitted successfully. Awaiting manual verification.\",\n+            message: \"Payment submitted successfully. Awaiting M-Pesa verification.\",\n             paymentId: newPaymentId\n         });\n \n     } catch (err) {\n-        console.error(\"Error submitting payment or M-Pesa STK Push failed:\", err.response?.data || err.message);\n-        // Handle database or network errors\n-        res.status(500).json({ message: \"Error processing payment\", details: err.response?.data?.errorMessage || err.message });\n+        console.error(\"Error submitting payment:\", err);\n+        res.status(500).json({ message: \"Error submitting payment\", details: err.message });\n     }\n };\n+\n // ----------------------------------------------------------------------\n // ================= VERIFY PAYMENT (ADMIN ONLY) (UNIFIED & CORRECTED) =================\n // ----------------------------------------------------------------------\n export const verifyPayment = async (req, res) => {\n"
                },
                {
                    "date": 1763626039414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,10 +2,8 @@\n \n import sql from \"mssql\";\n // UNIFIED IMPORT: Use dbPool exported from server.js\n // backend/controllers/paymentsController.js\n-\n-import sql from \"mssql\";\n import { \n     dbPool, \n     SHORTCODE, \n     PASSKEY, \n"
                },
                {
                    "date": 1763626050019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n import sql from \"mssql\";\n // UNIFIED IMPORT: Use dbPool exported from server.js\n // backend/controllers/paymentsController.js\n import { \n-    dbPool, \n+   \n     SHORTCODE, \n     PASSKEY, \n     CALLBACK_URL,\n     getAccessToken // Import the function to get the token\n"
                },
                {
                    "date": 1763626629642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,269 +1,286 @@\n-// backend/controllers/paymentsController.js - COMPLETE CORRECTED & UNIFIED CODE\n+// backend/controllers/paymentsController.js\n \n import sql from \"mssql\";\n-// UNIFIED IMPORT: Use dbPool exported from server.js\n-// backend/controllers/paymentsController.js\n-import { \n-   \n-    SHORTCODE, \n-    PASSKEY, \n-    CALLBACK_URL,\n-    getAccessToken // Import the function to get the token\n-} from \"../server.js\"; // <-- Ensure these are correctly exported in server.js\n+import axios from \"axios\"; \n+import { dbPool, SHORTCODE, PASSKEY, CALLBACK_URL, getAccessToken } from \"../server.js\"; \n \n-// ... rest of the imports (like getIdentityFromReq and executeQuery helpers)\n \n-import axios from \"axios\"; // Need axios here for the M-Pesa request\n-import { dbPool } from \"../server.js\"; \n-// NOTE: dbConfig import removed as we use dbPool directly\n-\n // Helper: get identity from JWT\n const getIdentityFromReq = (req) => {\n-    const role = req.user?.role?.toLowerCase() || \"\";\n-    // Ensure ResidentID is treated as a Number/Int if that's its database type\n-    const residentId = req.user?.ResidentID ? parseInt(req.user.ResidentID, 10) : null; \n-    const verifierID = req.user?.UserID || req.user?.NationalID || 'ADMIN';\n-    return { role, residentId, verifierID };\n+  const role = req.user?.role?.toLowerCase() || \"\";\n+  // Ensure ResidentID is treated as a Number/Int if that's its database type\n+  const residentId = req.user?.ResidentID ? parseInt(req.user.ResidentID, 10) : null; \n+  const verifierID = req.user?.UserID || req.user?.NationalID || 'ADMIN';\n+  return { role, residentId, verifierID };\n };\n \n // Helper to execute a query using the central dbPool\n async function executeQuery(query, inputs = []) {\n-    const pool = await dbPool;\n-    const request = pool.request();\n-    inputs.forEach(input => request.input(input.name, input.type, input.value));\n-    return request.query(query);\n+  const pool = await dbPool;\n+  const request = pool.request();\n+  inputs.forEach(input => request.input(input.name, input.type, input.value));\n+  return request.query(query);\n }\n \n // ----------------------------------------------------------------------\n-// ================= GET ALL PAYMENTS (Updated to use executeQuery) =================\n+// ================= GET ALL PAYMENTS =================\n // ----------------------------------------------------------------------\n export const getPayments = async (req, res) => {\n-    const { role, residentId } = getIdentityFromReq(req);\n+  const { role, residentId } = getIdentityFromReq(req);\n \n-    try {\n-        let query = `\n-            SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod, PhoneNumber\n-            FROM Payments\n-            ORDER BY PaymentDate DESC\n-        `;\n+  try {\n+    let query = `\n+      SELECT \n+                p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+                p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+                r.ResidentName,\n+                r.NationalID\n+      FROM Payments p\n+            JOIN Residents r ON p.ResidentID = r.ResidentID\n+      ORDER BY p.PaymentDate DESC\n+    `;\n \n-        const inputs = [];\n-        if (role === \"resident\") {\n-            query = `\n-                SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod, PhoneNumber\n-                FROM Payments\n-                WHERE ResidentID = @ResidentID\n-                ORDER BY PaymentDate DESC\n-            `;\n-            inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n-        }\n+    const inputs = [];\n+    if (role === \"resident\") {\n+      query = `\n+        SELECT \n+                    p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+                    p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+                    r.ResidentName,\n+                    r.NationalID\n+        FROM Payments p\n+                JOIN Residents r ON p.ResidentID = r.ResidentID\n+        WHERE p.ResidentID = @ResidentID\n+        ORDER BY p.PaymentDate DESC\n+      `;\n+      inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n+    }\n \n-        const result = await executeQuery(query, inputs);\n-        res.json(result.recordset);\n+    const result = await executeQuery(query, inputs);\n+    res.json(result.recordset);\n \n-    } catch (err) {\n-        console.error(\"Error fetching payments:\", err);\n-        res.status(500).json({ message: \"Error fetching payments\" });\n-    }\n+  } catch (err) {\n+    console.error(\"Error fetching payments:\", err);\n+    res.status(500).json({ message: \"Error fetching payments\" });\n+  }\n };\n \n // ----------------------------------------------------------------------\n-// ================= GET VERIFIED PAYMENTS (Updated to use executeQuery) =================\n+// ================= GET VERIFIED PAYMENTS =================\n // ----------------------------------------------------------------------\n export const getVerifiedPayments = async (req, res) => {\n-    const { role, residentId } = getIdentityFromReq(req);\n+  const { role, residentId } = getIdentityFromReq(req);\n \n-    try {\n-        let query = `\n-            SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod, PhoneNumber\n-            FROM Payments\n-            WHERE Status='Verified'\n-            ORDER BY PaymentDate DESC\n-        `;\n+  try {\n+    let query = `\n+      SELECT \n+                p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+                p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+                r.ResidentName,\n+                r.NationalID\n+      FROM Payments p\n+            JOIN Residents r ON p.ResidentID = r.ResidentID\n+      WHERE p.Status='Verified'\n+      ORDER BY p.PaymentDate DESC\n+    `;\n \n-        const inputs = [];\n-        if (role === \"resident\") {\n-            query = `\n-                SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod, PhoneNumber\n-                FROM Payments\n-                WHERE Status='Verified' AND ResidentID = @ResidentID\n-                ORDER BY PaymentDate DESC\n-            `;\n-            inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n-        }\n+    const inputs = [];\n+    if (role === \"resident\") {\n+      query = `\n+        SELECT \n+                    p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+                    p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+                    r.ResidentName,\n+                    r.NationalID\n+        FROM Payments p\n+                JOIN Residents r ON p.ResidentID = r.ResidentID\n+        WHERE p.Status='Verified' AND p.ResidentID = @ResidentID\n+        ORDER BY p.PaymentDate DESC\n+      `;\n+      inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n+    }\n \n-        const result = await executeQuery(query, inputs);\n-        res.json(result.recordset);\n+    const result = await executeQuery(query, inputs);\n+    res.json(result.recordset);\n \n-    } catch (err) {\n-        console.error(\"Error fetching verified payments:\", err);\n-        res.status(500).json({ message: \"Error fetching verified payments\" });\n-    }\n+  } catch (err) {\n+    console.error(\"Error fetching verified payments:\", err);\n+    res.status(500).json({ message: \"Error fetching verified payments\" });\n+  }\n };\n \n // ----------------------------------------------------------------------\n-// ================= GET BALANCES (Updated to use executeQuery) =================\n+// ================= GET BALANCES =================\n // ----------------------------------------------------------------------\n export const getBalances = async (req, res) => {\n-    const { role, residentId } = getIdentityFromReq(req);\n+  const { role, residentId } = getIdentityFromReq(req);\n \n-    try {\n-        let query = `\n-            SELECT \n-                r.ResidentID,\n-                r.ResidentName,\n-                ISNULL(SUM(p.Amount), 0) AS TotalPaid,\n-                ISNULL(r.TotalDue, 0) AS TotalDue,\n-                (ISNULL(r.TotalDue,0) - ISNULL(SUM(p.Amount),0)) AS Balance\n-            FROM Residents r\n-            LEFT JOIN Payments p\n-                ON r.ResidentID = p.ResidentID AND p.Status='Verified'\n-        `;\n+  try {\n+    let query = `\n+      SELECT \n+        r.ResidentID,\n+        r.ResidentName,\n+        ISNULL(SUM(p.Amount), 0) AS TotalPaid,\n+        ISNULL(r.TotalDue, 0) AS TotalDue,\n+        (ISNULL(r.TotalDue,0) - ISNULL(SUM(p.Amount),0)) AS Balance\n+      FROM Residents r\n+      LEFT JOIN Payments p\n+        ON r.ResidentID = p.ResidentID AND p.Status='Verified'\n+    `;\n \n-        const inputs = [];\n-        if (role === \"resident\") {\n-            query += \" WHERE r.ResidentID = @ResidentID\";\n-            inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n-        }\n+    const inputs = [];\n+    if (role === \"resident\") {\n+      query += \" WHERE r.ResidentID = @ResidentID\";\n+      inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n+    }\n \n-        query += \" GROUP BY r.ResidentID, r.ResidentName, r.TotalDue\";\n+    query += \" GROUP BY r.ResidentID, r.ResidentName, r.TotalDue\";\n \n-        const result = await executeQuery(query, inputs);\n-        res.json(result.recordset);\n+    const result = await executeQuery(query, inputs);\n+    res.json(result.recordset);\n \n-    } catch (err) {\n-        console.error(\"Error fetching balances:\", err);\n-        res.status(500).json({ message: \"Error fetching balances\" });\n-    }\n+  } catch (err) {\n+    console.error(\"Error fetching balances:\", err);\n+    res.status(500).json({ message: \"Error fetching balances\" });\n+  }\n };\n \n // ----------------------------------------------------------------------\n // ================= MAKE PAYMENT (UNIFIED & CORRECTED) =================\n // ----------------------------------------------------------------------\n export const makePayment = async (req, res) => {\n-    const { role, residentId: authResidentId } = getIdentityFromReq(req);\n-    const { residentId, amount, paymentMethod, reference, phone } = req.body;\n+  const { role, residentId: authResidentId } = getIdentityFromReq(req);\n+  const { residentId, amount, paymentMethod, reference, phone } = req.body;\n \n-    // Authorization Check: Prevent residents from paying for others\n-    if (role === \"resident\" && parseInt(residentId, 10) !== authResidentId) {\n-        return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n+  // Authorization Check: Prevent residents from paying for others\n+  if (role === \"resident\" && parseInt(residentId, 10) !== authResidentId) {\n+    return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n+  }\n+  \n+  // Data Validation\n+  if (!residentId || !amount || !paymentMethod || !phone) {\n+    return res.status(400).json({ message: \"Missing required fields (residentId, amount, paymentMethod, phone).\" });\n+  }\n+\n+  try {\n\\ No newline at end of file\n+    // Check if the resident exists before creating a payment\n+    const residentCheck = await executeQuery(\n+      `SELECT ResidentID FROM Residents WHERE ResidentID = @ResidentID`, \n+      [{ name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) }]\n+    );\n+    if (residentCheck.recordset.length === 0) {\n+      return res.status(404).json({ message: \"Resident not found.\" });\n     }\n+\n+    const query = `\n+      INSERT INTO Payments \n+      (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate, PhoneNumber)\n+      OUTPUT INSERTED.PaymentID\n+      VALUES (@ResidentID, @Amount, @PaymentMethod, @Reference, 'Pending', GETDATE(), @PhoneNumber);\n+    `;\n     \n-    // Data Validation\n-    if (!residentId || !amount || !paymentMethod || !phone) {\n-        return res.status(400).json({ message: \"Missing required fields (residentId, amount, paymentMethod, phone).\" });\n-    }\n+    const inputs = [\n+      { name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) },\n+      { name: \"Amount\", type: sql.Decimal(10, 2), value: amount },\n+      { name: \"PaymentMethod\", type: sql.VarChar(50), value: paymentMethod },\n+      { name: \"Reference\", type: sql.VarChar(100), value: reference || 'N/A' },\n+      { name: \"PhoneNumber\", type: sql.VarChar(20), value: phone },\n+    ];\n+    \n+    const result = await executeQuery(query, inputs);\n+    const newPaymentId = result.recordset[0]?.PaymentID;\n \n-    try {\n-        const query = `\n-            INSERT INTO Payments \n-            (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate, PhoneNumber)\n-            OUTPUT INSERTED.PaymentID\n-            VALUES (@ResidentID, @Amount, @PaymentMethod, @Reference, 'Pending', GETDATE(), @PhoneNumber);\n-        `;\n-        \n-        const inputs = [\n-            { name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) },\n-            { name: \"Amount\", type: sql.Decimal(10, 2), value: amount },\n-            { name: \"PaymentMethod\", type: sql.VarChar(50), value: paymentMethod },\n-            { name: \"Reference\", type: sql.VarChar(100), value: reference || 'N/A' },\n-            { name: \"PhoneNumber\", type: sql.VarChar(20), value: phone },\n-        ];\n-        \n-        const result = await executeQuery(query, inputs);\n-        const newPaymentId = result.recordset[0]?.PaymentID;\n+    res.status(201).json({ \n+      message: \"Payment submitted successfully. Awaiting verification.\",\n+      paymentId: newPaymentId\n+    });\n \n-        res.status(201).json({ \n-            message: \"Payment submitted successfully. Awaiting M-Pesa verification.\",\n-            paymentId: newPaymentId\n-        });\n-\n-    } catch (err) {\n-        console.error(\"Error submitting payment:\", err);\n-        res.status(500).json({ message: \"Error submitting payment\", details: err.message });\n-    }\n+  } catch (err) {\n+    console.error(\"Error submitting payment:\", err);\n+    res.status(500).json({ message: \"Error submitting payment\", details: err.message });\n+  }\n };\n \n // ----------------------------------------------------------------------\n-// ================= VERIFY PAYMENT (ADMIN ONLY) (UNIFIED & CORRECTED) =================\n+// ================= VERIFY PAYMENT (ADMIN ONLY) =================\n // ----------------------------------------------------------------------\n export const verifyPayment = async (req, res) => {\n-    const { role, verifierID } = getIdentityFromReq(req);\n-    const { id } = req.params;\n-    const verificationDate = new Date();\n+  const { role, verifierID } = getIdentityFromReq(req);\n+  const { id } = req.params;\n+  const verificationDate = new Date();\n \n-    if (role !== \"admin\") {\n-        return res.status(403).json({ message: \"Unauthorized\" });\n-    }\n+  if (role !== \"admin\") {\n+    return res.status(403).json({ message: \"Unauthorized\" });\n+  }\n \n-    try {\n-        if (!id) return res.status(400).json({ message: \"Payment ID missing.\" });\n+  try {\n+    if (!id) return res.status(400).json({ message: \"Payment ID missing.\" });\n \n-        const query = `\n-            UPDATE Payments \n-            SET \n-                Status = 'Verified', \n-                VerifiedBy = @VerifierID, \n-                VerifiedDate = @VerifiedDate\n-            WHERE PaymentID = @PaymentID AND Status <> 'Verified';\n-        `;\n-        \n-        const inputs = [\n-            { name: \"PaymentID\", type: sql.Int, value: id },\n-            { name: \"VerifierID\", type: sql.VarChar(50), value: verifierID.toString() },\n-            { name: \"VerifiedDate\", type: sql.DateTime, value: verificationDate },\n-        ];\n-        \n-        const result = await executeQuery(query, inputs);\n+    const query = `\n+      UPDATE Payments \n+      SET \n+        Status = 'Verified', \n+        VerifiedBy = @VerifierID, \n+        VerifiedDate = @VerifiedDate\n+      WHERE PaymentID = @PaymentID AND Status <> 'Verified';\n+    `;\n+    \n+    const inputs = [\n+      { name: \"PaymentID\", type: sql.Int, value: parseInt(id, 10) },\n+      { name: \"VerifierID\", type: sql.VarChar(50), value: verifierID.toString() },\n+      { name: \"VerifiedDate\", type: sql.DateTime, value: verificationDate },\n+    ];\n+    \n+    const result = await executeQuery(query, inputs);\n \n-        if (result.rowsAffected[0] === 0) {\n-            // This is crucial: check if the payment was already Verified\n-            const checkQuery = await executeQuery(`SELECT Status FROM Payments WHERE PaymentID = @PaymentID`, [{ name: \"PaymentID\", type: sql.Int, value: id }]);\n-            \n-            if (checkQuery.recordset.length === 0) {\n-                 return res.status(404).json({ message: \"Payment not found.\" });\n-            }\n+    if (result.rowsAffected[0] === 0) {\n+      // Check if the payment was already Verified or doesn't exist\n+      const checkQuery = await executeQuery(`SELECT Status FROM Payments WHERE PaymentID = @PaymentID`, [{ name: \"PaymentID\", type: sql.Int, value: id }]);\n+      \n+      if (checkQuery.recordset.length === 0) {\n+        return res.status(404).json({ message: \"Payment not found.\" });\n+      }\n \n-            return res.status(200).json({ message: `Payment ${id} was already verified or update failed.` });\n-        }\n+      return res.status(200).json({ message: `Payment ${id} was already verified or update failed (no state change).` });\n+    }\n \n-        res.json({ message: `Payment ${id} verified successfully.` });\n+    res.json({ message: `Payment ${id} verified successfully.` });\n \n-    } catch (err) {\n-        console.error(\"DB Error in verifyPayment:\", err);\n-        res.status(500).json({ message: \"Failed to verify payment.\", details: err.message });\n-    }\n+  } catch (err) {\n+    console.error(\"DB Error in verifyPayment:\", err);\n+    res.status(500).json({ message: \"Failed to verify payment.\", details: err.message });\n+  }\n };\n-// Add this to backend/controllers/paymentsController.js\n \n // -------------------------------------------------------------\n-// GET PAYMENT SUMMARY (NEW)\n+// GET PAYMENT SUMMARY \n // -------------------------------------------------------------\n export async function getPaymentSummary(req, res) {\n-    try {\n-        const pool = await dbPool;\n-        \n-        const result = await pool.request().query(`\n-            SELECT \n-                COUNT(*) AS totalPayments,\n-                SUM(CASE WHEN Status = 'Verified' THEN 1 ELSE 0 END) AS totalVerified,\n-                SUM(CASE WHEN Status = 'Pending' THEN 1 ELSE 0 END) AS totalPending\n-            FROM Payments\n-        `);\n+  try {\n+    const pool = await dbPool;\n+    \n+    const result = await pool.request().query(`\n+      SELECT \n+        COUNT(*) AS totalPayments,\n+        ISNULL(SUM(CASE WHEN Status = 'Verified' THEN 1 ELSE 0 END), 0) AS totalVerified,\n+        ISNULL(SUM(CASE WHEN Status = 'Pending' THEN 1 ELSE 0 END), 0) AS totalPending\n+      FROM Payments\n+    `);\n \n-        if (result.recordset.length === 0) {\n-             return res.json({ totalPayments: 0, totalVerified: 0, totalPending: 0 });\n-        }\n+    if (result.recordset.length === 0) {\n+      return res.json({ totalPayments: 0, totalVerified: 0, totalPending: 0 });\n+    }\n \n-        res.json(result.recordset[0]);\n+    // Ensure counts are returned as numbers\n+    const data = result.recordset[0];\n+    res.json({\n+      totalPayments: parseInt(data.totalPayments),\n+      totalVerified: parseInt(data.totalVerified),\n+      totalPending: parseInt(data.totalPending)\n+    });\n \n-    } catch (err) {\n-        console.error(\"DB Error in getPaymentSummary:\", err);\n-        res.status(500).json({ message: \"Failed to fetch payment summary.\" });\n-    }\n-}\n-// -------------------------------------------------------------\n-// GET LOGIC (Simplified & Consolidated)\n-// -------------------------------------------------------------\n-// NOTE: getPayments, getVerifiedPayments, and getBalances are already defined above.\n-// The executeQuery helper function is now used by all of them for a unified style.\n+  } catch (err) {\n+    console.error(\"DB Error in getPaymentSummary:\", err);\n+    res.status(500).json({ message: \"Failed to fetch payment summary.\" });\n+  }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763629500696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,286 +1,286 @@\n-// backend/controllers/paymentsController.js\n+  // backend/controllers/paymentsController.js\n \n-import sql from \"mssql\";\n-import axios from \"axios\"; \n-import { dbPool, SHORTCODE, PASSKEY, CALLBACK_URL, getAccessToken } from \"../server.js\"; \n+  import sql from \"mssql\";\n+  import axios from \"axios\"; \n+  import { dbPool, SHORTCODE, PASSKEY, CALLBACK_URL, getAccessToken } from \"../server.js\"; \n \n \n-// Helper: get identity from JWT\n-const getIdentityFromReq = (req) => {\n-  const role = req.user?.role?.toLowerCase() || \"\";\n-  // Ensure ResidentID is treated as a Number/Int if that's its database type\n-  const residentId = req.user?.ResidentID ? parseInt(req.user.ResidentID, 10) : null; \n-  const verifierID = req.user?.UserID || req.user?.NationalID || 'ADMIN';\n-  return { role, residentId, verifierID };\n-};\n+  // Helper: get identity from JWT\n+  const getIdentityFromReq = (req) => {\n+    const role = req.user?.role?.toLowerCase() || \"\";\n+    // Ensure ResidentID is treated as a Number/Int if that's its database type\n+    const residentId = req.user?.ResidentID ? parseInt(req.user.ResidentID, 10) : null; \n+    const verifierID = req.user?.UserID || req.user?.NationalID || 'ADMIN';\n+    return { role, residentId, verifierID };\n+  };\n \n-// Helper to execute a query using the central dbPool\n-async function executeQuery(query, inputs = []) {\n-  const pool = await dbPool;\n-  const request = pool.request();\n-  inputs.forEach(input => request.input(input.name, input.type, input.value));\n-  return request.query(query);\n-}\n+  // Helper to execute a query using the central dbPool\n+  async function executeQuery(query, inputs = []) {\n+    const pool = await dbPool;\n+    const request = pool.request();\n+    inputs.forEach(input => request.input(input.name, input.type, input.value));\n+    return request.query(query);\n+  }\n \n-// ----------------------------------------------------------------------\n-// ================= GET ALL PAYMENTS =================\n-// ----------------------------------------------------------------------\n-export const getPayments = async (req, res) => {\n-  const { role, residentId } = getIdentityFromReq(req);\n+  // ----------------------------------------------------------------------\n+  // ================= GET ALL PAYMENTS =================\n+  // ----------------------------------------------------------------------\n+  export const getPayments = async (req, res) => {\n+    const { role, residentId } = getIdentityFromReq(req);\n \n-  try {\n-    let query = `\n-      SELECT \n-                p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n-                p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n-                r.ResidentName,\n-                r.NationalID\n-      FROM Payments p\n-            JOIN Residents r ON p.ResidentID = r.ResidentID\n-      ORDER BY p.PaymentDate DESC\n-    `;\n-\n-    const inputs = [];\n-    if (role === \"resident\") {\n-      query = `\n+    try {\n+      let query = `\n         SELECT \n-                    p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n-                    p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n-                    r.ResidentName,\n-                    r.NationalID\n+                  p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+                  p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+                  r.ResidentName,\n+                  r.NationalID\n         FROM Payments p\n-                JOIN Residents r ON p.ResidentID = r.ResidentID\n-        WHERE p.ResidentID = @ResidentID\n+              JOIN Residents r ON p.ResidentID = r.ResidentID\n         ORDER BY p.PaymentDate DESC\n       `;\n-      inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n-    }\n \n-    const result = await executeQuery(query, inputs);\n-    res.json(result.recordset);\n+      const inputs = [];\n+      if (role === \"resident\") {\n+        query = `\n+          SELECT \n+                      p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+                      p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+                      r.ResidentName,\n+                      r.NationalID\n+          FROM Payments p\n+                  JOIN Residents r ON p.ResidentID = r.ResidentID\n+          WHERE p.ResidentID = @ResidentID\n+          ORDER BY p.PaymentDate DESC\n+        `;\n+        inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n+      }\n \n-  } catch (err) {\n-    console.error(\"Error fetching payments:\", err);\n-    res.status(500).json({ message: \"Error fetching payments\" });\n-  }\n-};\n+      const result = await executeQuery(query, inputs);\n+      res.json(result.recordset);\n \n-// ----------------------------------------------------------------------\n-// ================= GET VERIFIED PAYMENTS =================\n-// ----------------------------------------------------------------------\n-export const getVerifiedPayments = async (req, res) => {\n-  const { role, residentId } = getIdentityFromReq(req);\n+    } catch (err) {\n+      console.error(\"Error fetching payments:\", err);\n+      res.status(500).json({ message: \"Error fetching payments\" });\n+    }\n+  };\n \n-  try {\n-    let query = `\n-      SELECT \n-                p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n-                p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n-                r.ResidentName,\n-                r.NationalID\n-      FROM Payments p\n-            JOIN Residents r ON p.ResidentID = r.ResidentID\n-      WHERE p.Status='Verified'\n-      ORDER BY p.PaymentDate DESC\n-    `;\n+  // ----------------------------------------------------------------------\n+  // ================= GET VERIFIED PAYMENTS =================\n+  // ----------------------------------------------------------------------\n+  export const getVerifiedPayments = async (req, res) => {\n+    const { role, residentId } = getIdentityFromReq(req);\n \n-    const inputs = [];\n-    if (role === \"resident\") {\n-      query = `\n+    try {\n+      let query = `\n         SELECT \n-                    p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n-                    p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n-                    r.ResidentName,\n-                    r.NationalID\n+                  p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+                  p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+                  r.ResidentName,\n+                  r.NationalID\n         FROM Payments p\n-                JOIN Residents r ON p.ResidentID = r.ResidentID\n-        WHERE p.Status='Verified' AND p.ResidentID = @ResidentID\n+              JOIN Residents r ON p.ResidentID = r.ResidentID\n+        WHERE p.Status='Verified'\n         ORDER BY p.PaymentDate DESC\n       `;\n-      inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n-    }\n \n-    const result = await executeQuery(query, inputs);\n-    res.json(result.recordset);\n+      const inputs = [];\n+      if (role === \"resident\") {\n+        query = `\n+          SELECT \n+                      p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+                      p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+                      r.ResidentName,\n+                      r.NationalID\n+          FROM Payments p\n+                  JOIN Residents r ON p.ResidentID = r.ResidentID\n+          WHERE p.Status='Verified' AND p.ResidentID = @ResidentID\n+          ORDER BY p.PaymentDate DESC\n+        `;\n+        inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n+      }\n \n-  } catch (err) {\n-    console.error(\"Error fetching verified payments:\", err);\n-    res.status(500).json({ message: \"Error fetching verified payments\" });\n-  }\n-};\n+      const result = await executeQuery(query, inputs);\n+      res.json(result.recordset);\n \n-// ----------------------------------------------------------------------\n-// ================= GET BALANCES =================\n-// ----------------------------------------------------------------------\n-export const getBalances = async (req, res) => {\n-  const { role, residentId } = getIdentityFromReq(req);\n+    } catch (err) {\n+      console.error(\"Error fetching verified payments:\", err);\n+      res.status(500).json({ message: \"Error fetching verified payments\" });\n+    }\n+  };\n \n-  try {\n-    let query = `\n-      SELECT \n-        r.ResidentID,\n-        r.ResidentName,\n-        ISNULL(SUM(p.Amount), 0) AS TotalPaid,\n-        ISNULL(r.TotalDue, 0) AS TotalDue,\n-        (ISNULL(r.TotalDue,0) - ISNULL(SUM(p.Amount),0)) AS Balance\n-      FROM Residents r\n-      LEFT JOIN Payments p\n-        ON r.ResidentID = p.ResidentID AND p.Status='Verified'\n-    `;\n+  // ----------------------------------------------------------------------\n+  // ================= GET BALANCES =================\n+  // ----------------------------------------------------------------------\n+  export const getBalances = async (req, res) => {\n+    const { role, residentId } = getIdentityFromReq(req);\n \n-    const inputs = [];\n-    if (role === \"resident\") {\n-      query += \" WHERE r.ResidentID = @ResidentID\";\n-      inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n-    }\n+    try {\n+      let query = `\n+        SELECT \n+          r.ResidentID,\n+          r.ResidentName,\n+          ISNULL(SUM(p.Amount), 0) AS TotalPaid,\n+          ISNULL(r.TotalDue, 0) AS TotalDue,\n+          (ISNULL(r.TotalDue,0) - ISNULL(SUM(p.Amount),0)) AS Balance\n+        FROM Residents r\n+        LEFT JOIN Payments p\n+          ON r.ResidentID = p.ResidentID AND p.Status='Verified'\n+      `;\n \n-    query += \" GROUP BY r.ResidentID, r.ResidentName, r.TotalDue\";\n+      const inputs = [];\n+      if (role === \"resident\") {\n+        query += \" WHERE r.ResidentID = @ResidentID\";\n+        inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n+      }\n \n-    const result = await executeQuery(query, inputs);\n-    res.json(result.recordset);\n+      query += \" GROUP BY r.ResidentID, r.ResidentName, r.TotalDue\";\n \n-  } catch (err) {\n-    console.error(\"Error fetching balances:\", err);\n-    res.status(500).json({ message: \"Error fetching balances\" });\n-  }\n-};\n+      const result = await executeQuery(query, inputs);\n+      res.json(result.recordset);\n \n-// ----------------------------------------------------------------------\n-// ================= MAKE PAYMENT (UNIFIED & CORRECTED) =================\n-// ----------------------------------------------------------------------\n-export const makePayment = async (req, res) => {\n-  const { role, residentId: authResidentId } = getIdentityFromReq(req);\n-  const { residentId, amount, paymentMethod, reference, phone } = req.body;\n+    } catch (err) {\n+      console.error(\"Error fetching balances:\", err);\n+      res.status(500).json({ message: \"Error fetching balances\" });\n+    }\n+  };\n \n-  // Authorization Check: Prevent residents from paying for others\n-  if (role === \"resident\" && parseInt(residentId, 10) !== authResidentId) {\n-    return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n-  }\n-  \n-  // Data Validation\n-  if (!residentId || !amount || !paymentMethod || !phone) {\n-    return res.status(400).json({ message: \"Missing required fields (residentId, amount, paymentMethod, phone).\" });\n-  }\n+  // ----------------------------------------------------------------------\n+  // ================= MAKE PAYMENT (UNIFIED & CORRECTED) =================\n+  // ----------------------------------------------------------------------\n+  export const makePayment = async (req, res) => {\n+    const { role, residentId: authResidentId } = getIdentityFromReq(req);\n\\ No newline at end of file\n+    const { residentId, amount, paymentMethod, reference, phone } = req.body;\n \n-  try {\n-    // Check if the resident exists before creating a payment\n-    const residentCheck = await executeQuery(\n-      `SELECT ResidentID FROM Residents WHERE ResidentID = @ResidentID`, \n-      [{ name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) }]\n-    );\n-    if (residentCheck.recordset.length === 0) {\n-      return res.status(404).json({ message: \"Resident not found.\" });\n+    // Authorization Check: Prevent residents from paying for others\n+    if (role === \"resident\" && parseInt(residentId, 10) !== authResidentId) {\n+      return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n     }\n-\n-    const query = `\n-      INSERT INTO Payments \n-      (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate, PhoneNumber)\n-      OUTPUT INSERTED.PaymentID\n-      VALUES (@ResidentID, @Amount, @PaymentMethod, @Reference, 'Pending', GETDATE(), @PhoneNumber);\n-    `;\n     \n-    const inputs = [\n-      { name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) },\n-      { name: \"Amount\", type: sql.Decimal(10, 2), value: amount },\n-      { name: \"PaymentMethod\", type: sql.VarChar(50), value: paymentMethod },\n-      { name: \"Reference\", type: sql.VarChar(100), value: reference || 'N/A' },\n-      { name: \"PhoneNumber\", type: sql.VarChar(20), value: phone },\n-    ];\n-    \n-    const result = await executeQuery(query, inputs);\n-    const newPaymentId = result.recordset[0]?.PaymentID;\n+    // Data Validation\n+    if (!residentId || !amount || !paymentMethod || !phone) {\n+      return res.status(400).json({ message: \"Missing required fields (residentId, amount, paymentMethod, phone).\" });\n+    }\n \n-    res.status(201).json({ \n-      message: \"Payment submitted successfully. Awaiting verification.\",\n-      paymentId: newPaymentId\n-    });\n+    try {\n+      // Check if the resident exists before creating a payment\n+      const residentCheck = await executeQuery(\n+        `SELECT ResidentID FROM Residents WHERE ResidentID = @ResidentID`, \n+        [{ name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) }]\n+      );\n+      if (residentCheck.recordset.length === 0) {\n+        return res.status(404).json({ message: \"Resident not found.\" });\n+      }\n \n-  } catch (err) {\n-    console.error(\"Error submitting payment:\", err);\n-    res.status(500).json({ message: \"Error submitting payment\", details: err.message });\n-  }\n-};\n+      const query = `\n+        INSERT INTO Payments \n+        (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate, PhoneNumber)\n+        OUTPUT INSERTED.PaymentID\n+        VALUES (@ResidentID, @Amount, @PaymentMethod, @Reference, 'Pending', GETDATE(), @PhoneNumber);\n+      `;\n+      \n+      const inputs = [\n+        { name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) },\n+        { name: \"Amount\", type: sql.Decimal(10, 2), value: amount },\n+        { name: \"PaymentMethod\", type: sql.VarChar(50), value: paymentMethod },\n+        { name: \"Reference\", type: sql.VarChar(100), value: reference || 'N/A' },\n+        { name: \"PhoneNumber\", type: sql.VarChar(20), value: phone },\n+      ];\n+      \n+      const result = await executeQuery(query, inputs);\n+      const newPaymentId = result.recordset[0]?.PaymentID;\n \n-// ----------------------------------------------------------------------\n-// ================= VERIFY PAYMENT (ADMIN ONLY) =================\n-// ----------------------------------------------------------------------\n-export const verifyPayment = async (req, res) => {\n-  const { role, verifierID } = getIdentityFromReq(req);\n-  const { id } = req.params;\n-  const verificationDate = new Date();\n+      res.status(201).json({ \n+        message: \"Payment submitted successfully. Awaiting verification.\",\n+        paymentId: newPaymentId\n+      });\n \n-  if (role !== \"admin\") {\n-    return res.status(403).json({ message: \"Unauthorized\" });\n-  }\n+    } catch (err) {\n+      console.error(\"Error submitting payment:\", err);\n+      res.status(500).json({ message: \"Error submitting payment\", details: err.message });\n+    }\n+  };\n \n-  try {\n-    if (!id) return res.status(400).json({ message: \"Payment ID missing.\" });\n+  // ----------------------------------------------------------------------\n+  // ================= VERIFY PAYMENT (ADMIN ONLY) =================\n+  // ----------------------------------------------------------------------\n+  export const verifyPayment = async (req, res) => {\n+    const { role, verifierID } = getIdentityFromReq(req);\n+    const { id } = req.params;\n+    const verificationDate = new Date();\n \n-    const query = `\n-      UPDATE Payments \n-      SET \n-        Status = 'Verified', \n-        VerifiedBy = @VerifierID, \n-        VerifiedDate = @VerifiedDate\n-      WHERE PaymentID = @PaymentID AND Status <> 'Verified';\n-    `;\n-    \n-    const inputs = [\n-      { name: \"PaymentID\", type: sql.Int, value: parseInt(id, 10) },\n-      { name: \"VerifierID\", type: sql.VarChar(50), value: verifierID.toString() },\n-      { name: \"VerifiedDate\", type: sql.DateTime, value: verificationDate },\n-    ];\n-    \n-    const result = await executeQuery(query, inputs);\n+    if (role !== \"admin\") {\n+      return res.status(403).json({ message: \"Unauthorized\" });\n+    }\n \n-    if (result.rowsAffected[0] === 0) {\n-      // Check if the payment was already Verified or doesn't exist\n-      const checkQuery = await executeQuery(`SELECT Status FROM Payments WHERE PaymentID = @PaymentID`, [{ name: \"PaymentID\", type: sql.Int, value: id }]);\n+    try {\n+      if (!id) return res.status(400).json({ message: \"Payment ID missing.\" });\n+\n+      const query = `\n+        UPDATE Payments \n+        SET \n+          Status = 'Verified', \n+          VerifiedBy = @VerifierID, \n+          VerifiedDate = @VerifiedDate\n+        WHERE PaymentID = @PaymentID AND Status <> 'Verified';\n+      `;\n       \n-      if (checkQuery.recordset.length === 0) {\n-        return res.status(404).json({ message: \"Payment not found.\" });\n+      const inputs = [\n+        { name: \"PaymentID\", type: sql.Int, value: parseInt(id, 10) },\n+        { name: \"VerifierID\", type: sql.VarChar(50), value: verifierID.toString() },\n+        { name: \"VerifiedDate\", type: sql.DateTime, value: verificationDate },\n+      ];\n+      \n+      const result = await executeQuery(query, inputs);\n+\n+      if (result.rowsAffected[0] === 0) {\n+        // Check if the payment was already Verified or doesn't exist\n+        const checkQuery = await executeQuery(`SELECT Status FROM Payments WHERE PaymentID = @PaymentID`, [{ name: \"PaymentID\", type: sql.Int, value: id }]);\n+        \n+        if (checkQuery.recordset.length === 0) {\n+          return res.status(404).json({ message: \"Payment not found.\" });\n+        }\n+\n+        return res.status(200).json({ message: `Payment ${id} was already verified or update failed (no state change).` });\n       }\n \n-      return res.status(200).json({ message: `Payment ${id} was already verified or update failed (no state change).` });\n+      res.json({ message: `Payment ${id} verified successfully.` });\n+\n+    } catch (err) {\n+      console.error(\"DB Error in verifyPayment:\", err);\n+      res.status(500).json({ message: \"Failed to verify payment.\", details: err.message });\n     }\n+  };\n \n-    res.json({ message: `Payment ${id} verified successfully.` });\n+  // -------------------------------------------------------------\n+  // GET PAYMENT SUMMARY \n+  // -------------------------------------------------------------\n+  export async function getPaymentSummary(req, res) {\n+    try {\n+      const pool = await dbPool;\n+      \n+      const result = await pool.request().query(`\n+        SELECT \n+          COUNT(*) AS totalPayments,\n+          ISNULL(SUM(CASE WHEN Status = 'Verified' THEN 1 ELSE 0 END), 0) AS totalVerified,\n+          ISNULL(SUM(CASE WHEN Status = 'Pending' THEN 1 ELSE 0 END), 0) AS totalPending\n+        FROM Payments\n+      `);\n \n-  } catch (err) {\n-    console.error(\"DB Error in verifyPayment:\", err);\n-    res.status(500).json({ message: \"Failed to verify payment.\", details: err.message });\n-  }\n-};\n+      if (result.recordset.length === 0) {\n+        return res.json({ totalPayments: 0, totalVerified: 0, totalPending: 0 });\n+      }\n \n-// -------------------------------------------------------------\n-// GET PAYMENT SUMMARY \n-// -------------------------------------------------------------\n-export async function getPaymentSummary(req, res) {\n-  try {\n-    const pool = await dbPool;\n-    \n-    const result = await pool.request().query(`\n-      SELECT \n-        COUNT(*) AS totalPayments,\n-        ISNULL(SUM(CASE WHEN Status = 'Verified' THEN 1 ELSE 0 END), 0) AS totalVerified,\n-        ISNULL(SUM(CASE WHEN Status = 'Pending' THEN 1 ELSE 0 END), 0) AS totalPending\n-      FROM Payments\n-    `);\n+      // Ensure counts are returned as numbers\n+      const data = result.recordset[0];\n+      res.json({\n+        totalPayments: parseInt(data.totalPayments),\n+        totalVerified: parseInt(data.totalVerified),\n+        totalPending: parseInt(data.totalPending)\n+      });\n \n-    if (result.recordset.length === 0) {\n-      return res.json({ totalPayments: 0, totalVerified: 0, totalPending: 0 });\n+    } catch (err) {\n+      console.error(\"DB Error in getPaymentSummary:\", err);\n+      res.status(500).json({ message: \"Failed to fetch payment summary.\" });\n     }\n-\n-    // Ensure counts are returned as numbers\n-    const data = result.recordset[0];\n-    res.json({\n-      totalPayments: parseInt(data.totalPayments),\n-      totalVerified: parseInt(data.totalVerified),\n-      totalPending: parseInt(data.totalPending)\n-    });\n-\n-  } catch (err) {\n-    console.error(\"DB Error in getPaymentSummary:\", err);\n-    res.status(500).json({ message: \"Failed to fetch payment summary.\" });\n-  }\n-}\n+  }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763632833008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,286 +1,291 @@\n-  // backend/controllers/paymentsController.js\n+// backend/controllers/paymentsController.js\n \n-  import sql from \"mssql\";\n-  import axios from \"axios\"; \n-  import { dbPool, SHORTCODE, PASSKEY, CALLBACK_URL, getAccessToken } from \"../server.js\"; \n+import sql from \"mssql\";\n+import axios from \"axios\";\n+import { dbPool, SHORTCODE, PASSKEY, CALLBACK_URL, getAccessToken } from \"../server.js\";\n \n+// Helper: get identity from JWT\n+const getIdentityFromReq = (req) => {\n+  const role = req.user?.role?.toLowerCase() || \"\";\n+  const residentId = req.user?.ResidentID ? parseInt(req.user.ResidentID, 10) : null;\n+  const verifierID = req.user?.UserID || req.user?.NationalID || 'ADMIN';\n+  return { role, residentId, verifierID };\n+};\n \n-  // Helper: get identity from JWT\n-  const getIdentityFromReq = (req) => {\n-    const role = req.user?.role?.toLowerCase() || \"\";\n-    // Ensure ResidentID is treated as a Number/Int if that's its database type\n-    const residentId = req.user?.ResidentID ? parseInt(req.user.ResidentID, 10) : null; \n-    const verifierID = req.user?.UserID || req.user?.NationalID || 'ADMIN';\n-    return { role, residentId, verifierID };\n-  };\n+// Helper to execute a query using the central dbPool\n+async function executeQuery(query, inputs = []) {\n+  const pool = await dbPool;\n+  const request = pool.request();\n+  inputs.forEach(input => request.input(input.name, input.type, input.value));\n+  return request.query(query);\n+}\n \n-  // Helper to execute a query using the central dbPool\n-  async function executeQuery(query, inputs = []) {\n-    const pool = await dbPool;\n-    const request = pool.request();\n-    inputs.forEach(input => request.input(input.name, input.type, input.value));\n-    return request.query(query);\n-  }\n+// ================= GET ALL PAYMENTS =================\n+export const getPayments = async (req, res) => {\n+  const { role, residentId } = getIdentityFromReq(req);\n \n-  // ----------------------------------------------------------------------\n-  // ================= GET ALL PAYMENTS =================\n-  // ----------------------------------------------------------------------\n-  export const getPayments = async (req, res) => {\n-    const { role, residentId } = getIdentityFromReq(req);\n+  try {\n+    let query = `\n+      SELECT \n+        p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+        p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+        r.ResidentName, r.NationalID\n+      FROM Payments p\n+      JOIN Residents r ON p.ResidentID = r.ResidentID\n+      ORDER BY p.PaymentDate DESC\n+    `;\n+    const inputs = [];\n \n-    try {\n-      let query = `\n+    if (role === \"resident\") {\n+      query = `\n         SELECT \n-                  p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n-                  p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n-                  r.ResidentName,\n-                  r.NationalID\n+          p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+          p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+          r.ResidentName, r.NationalID\n         FROM Payments p\n-              JOIN Residents r ON p.ResidentID = r.ResidentID\n+        JOIN Residents r ON p.ResidentID = r.ResidentID\n+        WHERE p.ResidentID = @ResidentID\n         ORDER BY p.PaymentDate DESC\n       `;\n+      inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n+    }\n \n-      const inputs = [];\n-      if (role === \"resident\") {\n-        query = `\n-          SELECT \n-                      p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n-                      p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n-                      r.ResidentName,\n-                      r.NationalID\n-          FROM Payments p\n-                  JOIN Residents r ON p.ResidentID = r.ResidentID\n-          WHERE p.ResidentID = @ResidentID\n-          ORDER BY p.PaymentDate DESC\n-        `;\n-        inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n-      }\n+    const result = await executeQuery(query, inputs);\n+    res.json(result.recordset);\n \n-      const result = await executeQuery(query, inputs);\n-      res.json(result.recordset);\n+  } catch (err) {\n+    console.error(\"Error fetching payments:\", err);\n+    res.status(500).json({ message: \"Error fetching payments\" });\n+  }\n+};\n \n-    } catch (err) {\n-      console.error(\"Error fetching payments:\", err);\n-      res.status(500).json({ message: \"Error fetching payments\" });\n+// ================= GET VERIFIED PAYMENTS =================\n+export const getVerifiedPayments = async (req, res) => {\n+  const { role, residentId } = getIdentityFromReq(req);\n+\n+  try {\n+    let query = `\n+      SELECT \n+        p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n+        p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n+        r.ResidentName, r.NationalID\n+      FROM Payments p\n+      JOIN Residents r ON p.ResidentID = r.ResidentID\n+      WHERE p.Status='Verified'\n+      ORDER BY p.PaymentDate DESC\n+    `;\n+    const inputs = [];\n+\n+    if (role === \"resident\") {\n+      query += \" AND p.ResidentID = @ResidentID\";\n+      inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n     }\n-  };\n \n-  // ----------------------------------------------------------------------\n-  // ================= GET VERIFIED PAYMENTS =================\n-  // ----------------------------------------------------------------------\n-  export const getVerifiedPayments = async (req, res) => {\n-    const { role, residentId } = getIdentityFromReq(req);\n+    const result = await executeQuery(query, inputs);\n+    res.json(result.recordset);\n \n-    try {\n-      let query = `\n-        SELECT \n-                  p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n-                  p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n-                  r.ResidentName,\n-                  r.NationalID\n-        FROM Payments p\n-              JOIN Residents r ON p.ResidentID = r.ResidentID\n-        WHERE p.Status='Verified'\n-        ORDER BY p.PaymentDate DESC\n-      `;\n+  } catch (err) {\n+    console.error(\"Error fetching verified payments:\", err);\n+    res.status(500).json({ message: \"Error fetching verified payments\" });\n+  }\n+};\n \n-      const inputs = [];\n-      if (role === \"resident\") {\n-        query = `\n-          SELECT \n-                      p.PaymentID, p.ResidentID, p.Amount, p.PaymentDate, p.Status, \n-                      p.Reference, p.PaymentMethod, p.PhoneNumber, p.VerifiedDate,\n-                      r.ResidentName,\n-                      r.NationalID\n-          FROM Payments p\n-                  JOIN Residents r ON p.ResidentID = r.ResidentID\n-          WHERE p.Status='Verified' AND p.ResidentID = @ResidentID\n-          ORDER BY p.PaymentDate DESC\n-        `;\n-        inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n-      }\n+// ================= GET BALANCES =================\n+export const getBalances = async (req, res) => {\n+  const { role, residentId } = getIdentityFromReq(req);\n \n-      const result = await executeQuery(query, inputs);\n-      res.json(result.recordset);\n+  try {\n+    let query = `\n+      SELECT \n+        r.ResidentID,\n+        r.ResidentName,\n+        ISNULL(SUM(p.Amount), 0) AS TotalPaid,\n+        ISNULL(r.TotalDue, 0) AS TotalDue,\n+        (ISNULL(r.TotalDue,0) - ISNULL(SUM(p.Amount),0)) AS Balance\n+      FROM Residents r\n+      LEFT JOIN Payments p\n+        ON r.ResidentID = p.ResidentID AND p.Status='Verified'\n+    `;\n+    const inputs = [];\n \n-    } catch (err) {\n-      console.error(\"Error fetching verified payments:\", err);\n-      res.status(500).json({ message: \"Error fetching verified payments\" });\n+    if (role === \"resident\") {\n+      query += \" WHERE r.ResidentID = @ResidentID\";\n+      inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n     }\n-  };\n \n-  // ----------------------------------------------------------------------\n-  // ================= GET BALANCES =================\n-  // ----------------------------------------------------------------------\n-  export const getBalances = async (req, res) => {\n-    const { role, residentId } = getIdentityFromReq(req);\n+    query += \" GROUP BY r.ResidentID, r.ResidentName, r.TotalDue\";\n+    const result = await executeQuery(query, inputs);\n+    res.json(result.recordset);\n \n-    try {\n-      let query = `\n-        SELECT \n-          r.ResidentID,\n-          r.ResidentName,\n-          ISNULL(SUM(p.Amount), 0) AS TotalPaid,\n-          ISNULL(r.TotalDue, 0) AS TotalDue,\n-          (ISNULL(r.TotalDue,0) - ISNULL(SUM(p.Amount),0)) AS Balance\n-        FROM Residents r\n-        LEFT JOIN Payments p\n-          ON r.ResidentID = p.ResidentID AND p.Status='Verified'\n-      `;\n+  } catch (err) {\n+    console.error(\"Error fetching balances:\", err);\n+    res.status(500).json({ message: \"Error fetching balances\" });\n+  }\n+};\n \n-      const inputs = [];\n-      if (role === \"resident\") {\n-        query += \" WHERE r.ResidentID = @ResidentID\";\n-        inputs.push({ name: \"ResidentID\", type: sql.Int, value: residentId });\n-      }\n+// ================= MAKE PAYMENT (MPESA STK PUSH) =================\n+export const makePayment = async (req, res) => {\n+  const { role, residentId: authResidentId } = getIdentityFromReq(req);\n+  const { residentId, amount, phone, reference } = req.body;\n \n-      query += \" GROUP BY r.ResidentID, r.ResidentName, r.TotalDue\";\n+  // Only allow resident to pay for themselves\n+  if (role === \"resident\" && parseInt(residentId, 10) !== authResidentId) {\n+    return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n+  }\n \n-      const result = await executeQuery(query, inputs);\n-      res.json(result.recordset);\n+  if (!residentId || !amount || !phone) {\n+    return res.status(400).json({ message: \"Missing required fields (residentId, amount, phone).\" });\n+  }\n \n-    } catch (err) {\n-      console.error(\"Error fetching balances:\", err);\n-      res.status(500).json({ message: \"Error fetching balances\" });\n+  try {\n+    // Check resident exists\n+    const residentCheck = await executeQuery(\n+      `SELECT ResidentID FROM Residents WHERE ResidentID = @ResidentID`, \n+      [{ name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) }]\n+    );\n+    if (residentCheck.recordset.length === 0) {\n+      return res.status(404).json({ message: \"Resident not found.\" });\n     }\n-  };\n \n-  // ----------------------------------------------------------------------\n-  // ================= MAKE PAYMENT (UNIFIED & CORRECTED) =================\n-  // ----------------------------------------------------------------------\n-  export const makePayment = async (req, res) => {\n-    const { role, residentId: authResidentId } = getIdentityFromReq(req);\n-    const { residentId, amount, paymentMethod, reference, phone } = req.body;\n+    // Get MPESA access token\n+    const token = await getAccessToken();\n+    const timestamp = new Date().toISOString().replace(/[-T:.Z]/g, '').slice(0, 14); // YYYYMMDDHHMMSS\n+    const password = Buffer.from(`${SHORTCODE}${PASSKEY}${timestamp}`).toString('base64');\n \n-    // Authorization Check: Prevent residents from paying for others\n-    if (role === \"resident\" && parseInt(residentId, 10) !== authResidentId) {\n-      return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n-    }\n-    \n-    // Data Validation\n-    if (!residentId || !amount || !paymentMethod || !phone) {\n\\ No newline at end of file\n-      return res.status(400).json({ message: \"Missing required fields (residentId, amount, paymentMethod, phone).\" });\n-    }\n-\n-    try {\n-      // Check if the resident exists before creating a payment\n-      const residentCheck = await executeQuery(\n-        `SELECT ResidentID FROM Residents WHERE ResidentID = @ResidentID`, \n-        [{ name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) }]\n-      );\n-      if (residentCheck.recordset.length === 0) {\n-        return res.status(404).json({ message: \"Resident not found.\" });\n+    // Make STK Push request\n+    const stkPushResponse = await axios.post(\n+      'https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest',\n+      {\n+        BusinessShortCode: SHORTCODE,\n+        Password: password,\n+        Timestamp: timestamp,\n+        TransactionType: 'CustomerPayBillOnline',\n+        Amount: parseFloat(amount),\n+        PartyA: phone.replace(/\\D/g,''), // remove +, spaces\n+        PartyB: SHORTCODE,\n+        PhoneNumber: phone.replace(/\\D/g,''),\n+        CallBackURL: CALLBACK_URL,\n+        AccountReference: reference || 'Payment',\n+        TransactionDesc: 'Resident Payment'\n+      },\n+      {\n+        headers: {\n+          Authorization: `Bearer ${token}`\n+        }\n       }\n+    );\n \n-      const query = `\n-        INSERT INTO Payments \n-        (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate, PhoneNumber)\n-        OUTPUT INSERTED.PaymentID\n-        VALUES (@ResidentID, @Amount, @PaymentMethod, @Reference, 'Pending', GETDATE(), @PhoneNumber);\n-      `;\n-      \n-      const inputs = [\n-        { name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) },\n-        { name: \"Amount\", type: sql.Decimal(10, 2), value: amount },\n-        { name: \"PaymentMethod\", type: sql.VarChar(50), value: paymentMethod },\n-        { name: \"Reference\", type: sql.VarChar(100), value: reference || 'N/A' },\n-        { name: \"PhoneNumber\", type: sql.VarChar(20), value: phone },\n-      ];\n-      \n-      const result = await executeQuery(query, inputs);\n-      const newPaymentId = result.recordset[0]?.PaymentID;\n+    // Save payment as Pending\n+    const query = `\n+      INSERT INTO Payments \n+      (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate, PhoneNumber)\n+      OUTPUT INSERTED.PaymentID\n+      VALUES (@ResidentID, @Amount, @PaymentMethod, @Reference, 'Pending', GETDATE(), @PhoneNumber);\n+    `;\n+    const inputs = [\n+      { name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) },\n+      { name: \"Amount\", type: sql.Decimal(10, 2), value: parseFloat(amount) },\n+      { name: \"PaymentMethod\", type: sql.VarChar(50), value: \"MPESA\" },\n+      { name: \"Reference\", type: sql.VarChar(100), value: reference || 'N/A' },\n+      { name: \"PhoneNumber\", type: sql.VarChar(20), value: phone },\n+    ];\n \n-      res.status(201).json({ \n-        message: \"Payment submitted successfully. Awaiting verification.\",\n-        paymentId: newPaymentId\n-      });\n+    const result = await executeQuery(query, inputs);\n+    const newPaymentId = result.recordset[0]?.PaymentID;\n \n-    } catch (err) {\n-      console.error(\"Error submitting payment:\", err);\n-      res.status(500).json({ message: \"Error submitting payment\", details: err.message });\n-    }\n-  };\n+    res.status(201).json({\n+      message: 'Payment initiated. Complete payment on your phone.',\n+      paymentId: newPaymentId,\n+      stkResponse: stkPushResponse.data\n+    });\n \n-  // ----------------------------------------------------------------------\n-  // ================= VERIFY PAYMENT (ADMIN ONLY) =================\n-  // ----------------------------------------------------------------------\n-  export const verifyPayment = async (req, res) => {\n-    const { role, verifierID } = getIdentityFromReq(req);\n-    const { id } = req.params;\n-    const verificationDate = new Date();\n+  } catch (err) {\n+    console.error(\"Error initiating MPESA payment:\", err);\n+    res.status(500).json({ message: \"Failed to initiate payment\", details: err.response?.data || err.message });\n+  }\n+};\n \n-    if (role !== \"admin\") {\n-      return res.status(403).json({ message: \"Unauthorized\" });\n-    }\n+// ================= VERIFY PAYMENT (ADMIN) =================\n+export const verifyPaymentAndArchive = async (req, res) => {\n+  const { role, verifierID } = getIdentityFromReq(req);\n+  const { id } = req.params;\n+  const verifiedDate = new Date();\n \n-    try {\n-      if (!id) return res.status(400).json({ message: \"Payment ID missing.\" });\n+  if (role !== \"admin\") return res.status(403).json({ message: \"Unauthorized\" });\n \n-      const query = `\n-        UPDATE Payments \n-        SET \n-          Status = 'Verified', \n-          VerifiedBy = @VerifierID, \n-          VerifiedDate = @VerifiedDate\n-        WHERE PaymentID = @PaymentID AND Status <> 'Verified';\n-      `;\n-      \n-      const inputs = [\n-        { name: \"PaymentID\", type: sql.Int, value: parseInt(id, 10) },\n-        { name: \"VerifierID\", type: sql.VarChar(50), value: verifierID.toString() },\n-        { name: \"VerifiedDate\", type: sql.DateTime, value: verificationDate },\n-      ];\n-      \n-      const result = await executeQuery(query, inputs);\n+  try {\n+    const query = `\n+      UPDATE Payments \n+      SET Status = 'Verified', VerifiedBy = @VerifierID, VerifiedDate = @VerifiedDate\n+      WHERE PaymentID = @PaymentID AND Status <> 'Verified';\n+    `;\n+    const inputs = [\n+      { name: \"PaymentID\", type: sql.Int, value: parseInt(id, 10) },\n+      { name: \"VerifierID\", type: sql.VarChar(50), value: verifierID },\n+      { name: \"VerifiedDate\", type: sql.DateTime, value: verifiedDate }\n+    ];\n \n-      if (result.rowsAffected[0] === 0) {\n-        // Check if the payment was already Verified or doesn't exist\n-        const checkQuery = await executeQuery(`SELECT Status FROM Payments WHERE PaymentID = @PaymentID`, [{ name: \"PaymentID\", type: sql.Int, value: id }]);\n-        \n-        if (checkQuery.recordset.length === 0) {\n-          return res.status(404).json({ message: \"Payment not found.\" });\n-        }\n+    const result = await executeQuery(query, inputs);\n \n-        return res.status(200).json({ message: `Payment ${id} was already verified or update failed (no state change).` });\n-      }\n+    if (result.rowsAffected[0] === 0) {\n+      const check = await executeQuery(\n+        `SELECT Status FROM Payments WHERE PaymentID=@PaymentID`, \n+        [{ name: \"PaymentID\", type: sql.Int, value: id }]\n+      );\n+      if (check.recordset.length === 0) return res.status(404).json({ message: \"Payment not found.\" });\n+      return res.status(200).json({ message: `Payment ${id} was already verified.` });\n+    }\n \n-      res.json({ message: `Payment ${id} verified successfully.` });\n+    res.json({ message: `Payment ${id} verified successfully.` });\n \n-    } catch (err) {\n-      console.error(\"DB Error in verifyPayment:\", err);\n-      res.status(500).json({ message: \"Failed to verify payment.\", details: err.message });\n-    }\n-  };\n+  } catch (err) {\n+    console.error(\"Error verifying payment:\", err);\n+    res.status(500).json({ message: \"Failed to verify payment.\", details: err.message });\n+  }\n+};\n \n-  // -------------------------------------------------------------\n-  // GET PAYMENT SUMMARY \n-  // -------------------------------------------------------------\n-  export async function getPaymentSummary(req, res) {\n-    try {\n-      const pool = await dbPool;\n-      \n-      const result = await pool.request().query(`\n-        SELECT \n-          COUNT(*) AS totalPayments,\n-          ISNULL(SUM(CASE WHEN Status = 'Verified' THEN 1 ELSE 0 END), 0) AS totalVerified,\n-          ISNULL(SUM(CASE WHEN Status = 'Pending' THEN 1 ELSE 0 END), 0) AS totalPending\n-        FROM Payments\n-      `);\n+// ================= GET PAYMENT SUMMARY =================\n+export const getPaymentSummary = async (req, res) => {\n+  try {\n+    const pool = await dbPool;\n+    const result = await pool.request().query(`\n+      SELECT \n+        COUNT(*) AS totalPayments,\n+        ISNULL(SUM(CASE WHEN Status='Verified' THEN 1 ELSE 0 END),0) AS totalVerified,\n+        ISNULL(SUM(CASE WHEN Status='Pending' THEN 1 ELSE 0 END),0) AS totalPending\n+      FROM Payments\n+    `);\n+    const data = result.recordset[0];\n+    res.json({\n+      totalPayments: parseInt(data.totalPayments),\n+      totalVerified: parseInt(data.totalVerified),\n+      totalPending: parseInt(data.totalPending)\n+    });\n+  } catch (err) {\n+    console.error(\"Error fetching payment summary:\", err);\n+    res.status(500).json({ message: \"Failed to fetch payment summary.\" });\n+  }\n+};\n \n-      if (result.recordset.length === 0) {\n-        return res.json({ totalPayments: 0, totalVerified: 0, totalPending: 0 });\n-      }\n+// ================= GET RECENT PAYMENTS =================\n+export const getRecentPayments = async (req, res) => {\n+  try {\n+    const limit = Number(req.query.limit) || 10;\n+    const pool = await dbPool;\n \n-      // Ensure counts are returned as numbers\n-      const data = result.recordset[0];\n-      res.json({\n-        totalPayments: parseInt(data.totalPayments),\n-        totalVerified: parseInt(data.totalVerified),\n-        totalPending: parseInt(data.totalPending)\n-      });\n+    const result = await pool.request().query(`\n+      SELECT TOP(${limit})\n+        p.PaymentID, r.ResidentName, p.Amount, p.PaymentMethod, p.PaymentDate,\n+        p.Reference, p.Status\n+      FROM Payments p\n+      JOIN Residents r ON p.ResidentID = r.ResidentID\n+      ORDER BY p.PaymentDate DESC\n+    `);\n \n-    } catch (err) {\n-      console.error(\"DB Error in getPaymentSummary:\", err);\n-      res.status(500).json({ message: \"Failed to fetch payment summary.\" });\n-    }\n-  }\n+    res.json(result.recordset);\n+\n+  } catch (err) {\n+    console.error(\"Error fetching recent payments:\", err);\n+    res.status(500).json({ message: \"Failed to fetch recent payments\" });\n+  }\n+};\n"
                },
                {
                    "date": 1763633283857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,26 @@\n // backend/controllers/paymentsController.js\n \n import sql from \"mssql\";\n import axios from \"axios\";\n-import { dbPool, SHORTCODE, PASSKEY, CALLBACK_URL, getAccessToken } from \"../server.js\";\n+import { dbPool } from \"../server.js\";\n \n+// Load environment variables for MPESA\n+const {\n+  MPESA_CONSUMER_KEY,\n+  MPESA_CONSUMER_SECRET,\n+  MPESA_SHORTCODE,\n+  MPESA_PASSKEY,\n+  MPESA_CALLBACK_URL,\n+  MPESA_ENV\n+} = process.env;\n+\n+const SHORTCODE = 174379;\n+const PASSKEY = bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919;\n+const CALLBACK_URL = \"https://yessenia-anthropocentric-nonpersonally.ngrok-free.dev/api/residents/payment-callback\";\n+const ENV = MPESA_ENV || 'sandbox';\n+const BASE_URL = ENV === 'production' ? 'https://api.safaricom.co.ke' : 'https://sandbox.safaricom.co.ke';\n+\n // Helper: get identity from JWT\n const getIdentityFromReq = (req) => {\n   const role = req.user?.role?.toLowerCase() || \"\";\n   const residentId = req.user?.ResidentID ? parseInt(req.user.ResidentID, 10) : null;\n@@ -19,8 +35,22 @@\n   inputs.forEach(input => request.input(input.name, input.type, input.value));\n   return request.query(query);\n }\n \n+// -------------------- MPESA ACCESS TOKEN --------------------\n+export const getAccessToken = async () => {\n+  try {\n+    const auth = Buffer.from(`${MPESA_CONSUMER_KEY}:${MPESA_CONSUMER_SECRET}`).toString('base64');\n+    const response = await axios.get(`${BASE_URL}/oauth/v1/generate?grant_type=client_credentials`, {\n+      headers: { Authorization: `Basic ${auth}` }\n+    });\n+    return response.data.access_token;\n+  } catch (err) {\n+    console.error(\"Error getting MPESA access token:\", err.response?.data || err.message);\n+    throw new Error(\"Failed to get MPESA access token\");\n+  }\n+};\n+\n // ================= GET ALL PAYMENTS =================\n export const getPayments = async (req, res) => {\n   const { role, residentId } = getIdentityFromReq(req);\n \n@@ -127,9 +157,8 @@\n export const makePayment = async (req, res) => {\n   const { role, residentId: authResidentId } = getIdentityFromReq(req);\n   const { residentId, amount, phone, reference } = req.body;\n \n-  // Only allow resident to pay for themselves\n   if (role === \"resident\" && parseInt(residentId, 10) !== authResidentId) {\n     return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n   }\n \n@@ -137,9 +166,8 @@\n     return res.status(400).json({ message: \"Missing required fields (residentId, amount, phone).\" });\n   }\n \n   try {\n-    // Check resident exists\n     const residentCheck = await executeQuery(\n       `SELECT ResidentID FROM Residents WHERE ResidentID = @ResidentID`, \n       [{ name: \"ResidentID\", type: sql.Int, value: parseInt(residentId, 10) }]\n     );\n@@ -148,35 +176,33 @@\n     }\n \n     // Get MPESA access token\n     const token = await getAccessToken();\n-    const timestamp = new Date().toISOString().replace(/[-T:.Z]/g, '').slice(0, 14); // YYYYMMDDHHMMSS\n+    const timestamp = new Date().toISOString().replace(/[-T:.Z]/g, '').slice(0, 14);\n     const password = Buffer.from(`${SHORTCODE}${PASSKEY}${timestamp}`).toString('base64');\n \n-    // Make STK Push request\n+    // STK Push\n     const stkPushResponse = await axios.post(\n-      'https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest',\n+      `${BASE_URL}/mpesa/stkpush/v1/processrequest`,\n       {\n         BusinessShortCode: SHORTCODE,\n         Password: password,\n         Timestamp: timestamp,\n         TransactionType: 'CustomerPayBillOnline',\n         Amount: parseFloat(amount),\n-        PartyA: phone.replace(/\\D/g,''), // remove +, spaces\n+        PartyA: phone.replace(/\\D/g,''),\n         PartyB: SHORTCODE,\n         PhoneNumber: phone.replace(/\\D/g,''),\n         CallBackURL: CALLBACK_URL,\n         AccountReference: reference || 'Payment',\n         TransactionDesc: 'Resident Payment'\n       },\n       {\n-        headers: {\n-          Authorization: `Bearer ${token}`\n-        }\n+        headers: { Authorization: `Bearer ${token}` }\n       }\n     );\n \n-    // Save payment as Pending\n+    // Save pending payment\n     const query = `\n       INSERT INTO Payments \n       (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate, PhoneNumber)\n       OUTPUT INSERTED.PaymentID\n@@ -188,9 +214,8 @@\n       { name: \"PaymentMethod\", type: sql.VarChar(50), value: \"MPESA\" },\n       { name: \"Reference\", type: sql.VarChar(100), value: reference || 'N/A' },\n       { name: \"PhoneNumber\", type: sql.VarChar(20), value: phone },\n     ];\n-\n     const result = await executeQuery(query, inputs);\n     const newPaymentId = result.recordset[0]?.PaymentID;\n \n     res.status(201).json({\n"
                },
                {
                    "date": 1763633364257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,9 @@\n \n // -------------------- MPESA ACCESS TOKEN --------------------\n export const getAccessToken = async () => {\n   try {\n-    const auth = Buffer.from(`${MPESA_CONSUMER_KEY}:${MPESA_CONSUMER_SECRET}`).toString('base64');\n+    const auth = Buffer.from(`${kmOLZ06AIGR4EtIovle2fwsLQU51YbWjdnSG516peEqwADAG}:${i3JqaV9P75jf5Uz60jhG2R4Ph4Ix9DJs2DbM8UvfCHIjfu2BOmO5i1UTjDeAc2Aj}`).toString('base64');\n     const response = await axios.get(`${BASE_URL}/oauth/v1/generate?grant_type=client_credentials`, {\n       headers: { Authorization: `Basic ${auth}` }\n     });\n     return response.data.access_token;\n"
                },
                {
                    "date": 1763633590623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -177,17 +177,17 @@\n \n     // Get MPESA access token\n     const token = await getAccessToken();\n     const timestamp = new Date().toISOString().replace(/[-T:.Z]/g, '').slice(0, 14);\n-    const password = Buffer.from(`${SHORTCODE}${PASSKEY}${timestamp}`).toString('base64');\n+    const password = Buffer.from(`${174379}${bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919}${YYYYMMDDHHMMSS}`).toString('base64');\n \n     // STK Push\n     const stkPushResponse = await axios.post(\n       `${BASE_URL}/mpesa/stkpush/v1/processrequest`,\n       {\n-        BusinessShortCode: SHORTCODE,\n-        Password: password,\n-        Timestamp: timestamp,\n+        BusinessShortCode: SHORTCODE || \"174379\",\n+        Password: password || \"Bev@Kon_2025\",\n+        Timestamp: timestamp || \"YYYYMMDDHHMMSS\",\n         TransactionType: 'CustomerPayBillOnline',\n         Amount: parseFloat(amount),\n         PartyA: phone.replace(/\\D/g,''),\n         PartyB: SHORTCODE,\n"
                },
                {
                    "date": 1763633655035,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -191,9 +191,9 @@\n         Amount: parseFloat(amount),\n         PartyA: phone.replace(/\\D/g,''),\n         PartyB: SHORTCODE,\n         PhoneNumber: phone.replace(/\\D/g,''),\n-        CallBackURL: CALLBACK_URL,\n+        CallBackURL: CALLBACK_URL || \"https://yessenia-anthropocentric-nonpersonally.ngrok-free.dev/api/residents/payment-callback\",\n         AccountReference: reference || 'Payment',\n         TransactionDesc: 'Resident Payment'\n       },\n       {\n"
                }
            ],
            "date": 1763620136789,
            "name": "Commit-0",
            "content": "// backend/controllers/paymentsController.js\nimport sql from \"mssql\";\nimport dbConfig from \"../config/dbConfig.js\";\nimport {dbpool} from \"../server.js\";\n// Helper: get identity from JWT\nconst getIdentityFromReq = (req) => {\n  const role = req.user?.role?.toLowerCase() || \"\";\n  const residentId = req.user?.ResidentID ?? null;\n  return { role, residentId };\n};\n\n// ================= GET ALL PAYMENTS =================\nexport const getPayments = async (req, res) => {\n  const { role, residentId } = getIdentityFromReq(req);\n\n  try {\n    const pool = await sql.connect(dbConfig);\n\n    let query = `\n      SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod\n      FROM Payments\n    `;\n\n    const request = pool.request();\n    if (role === \"resident\") {\n      query += \" WHERE ResidentID = @ResidentID\";\n      request.input(\"ResidentID\", sql.VarChar, residentId);\n    }\n\n    const result = await request.query(query);\n    res.json(result.recordset);\n\n  } catch (err) {\n    console.error(\"Error fetching payments:\", err);\n    res.status(500).json({ message: \"Error fetching payments\" });\n  }\n};\n\n// ================= GET VERIFIED PAYMENTS =================\nexport const getVerifiedPayments = async (req, res) => {\n  const { role, residentId } = getIdentityFromReq(req);\n\n  try {\n    const pool = await sql.connect(dbConfig);\n\n    let query = `\n      SELECT PaymentID, ResidentID, Amount, PaymentDate, Status, Reference, PaymentMethod\n      FROM Payments\n      WHERE Status='Verified'\n    `;\n\n    const request = pool.request();\n    if (role === \"resident\") {\n      query += \" AND ResidentID = @ResidentID\";\n      request.input(\"ResidentID\", sql.VarChar, residentId);\n    }\n\n    const result = await request.query(query);\n    res.json(result.recordset);\n\n  } catch (err) {\n    console.error(\"Error fetching verified payments:\", err);\n    res.status(500).json({ message: \"Error fetching verified payments\" });\n  }\n};\n\n// ================= GET BALANCES =================\nexport const getBalances = async (req, res) => {\n  const { role, residentId } = getIdentityFromReq(req);\n\n  try {\n    const pool = await sql.connect(dbConfig);\n\n    let query = `\n      SELECT \n        r.ResidentID,\n        r.ResidentName,\n        ISNULL(SUM(p.Amount), 0) AS TotalPaid,\n        ISNULL(r.TotalDue, 0) AS TotalDue,\n        (ISNULL(r.TotalDue,0) - ISNULL(SUM(p.Amount),0)) AS Balance\n      FROM Residents r\n      LEFT JOIN Payments p\n        ON r.ResidentID = p.ResidentID AND p.Status='Verified'\n    `;\n\n    if (role === \"resident\") {\n      query += \" WHERE r.ResidentID = @ResidentID\";\n    }\n\n    query += \" GROUP BY r.ResidentID, r.ResidentName, r.TotalDue\";\n\n    const request = pool.request();\n    if (role === \"resident\") request.input(\"ResidentID\", sql.VarChar, residentId);\n\n    const result = await request.query(query);\n    res.json(result.recordset);\n\n  } catch (err) {\n    console.error(\"Error fetching balances:\", err);\n    res.status(500).json({ message: \"Error fetching balances\" });\n  }\n};\n\n// ================= MAKE PAYMENT =================\nexport const makePayment = async (req, res) => {\n  const { role, residentId: authResidentId } = getIdentityFromReq(req);\n  const { residentId, amount, paymentMethod, reference } = req.body;\n\n  if (role === \"resident\" && residentId !== authResidentId) {\n    return res.status(403).json({ message: \"Unauthorized to pay for other residents\" });\n  }\n\n  try {\n    const pool = await sql.connect(dbConfig);\n    await pool.request()\n      .input(\"ResidentID\", sql.VarChar, residentId)\n      .input(\"Amount\", sql.Decimal(10,2), amount)\n      .input(\"PaymentMethod\", sql.VarChar, paymentMethod)\n      .input(\"Reference\", sql.VarChar, reference)\n      .input(\"Status\", sql.VarChar, \"Pending\")\n      .query(`\n        INSERT INTO Payments \n        (ResidentID, Amount, PaymentMethod, Reference, Status, PaymentDate)\n        VALUES (@ResidentID, @Amount, @PaymentMethod, @Reference, @Status, GETDATE())\n      `);\n\n    res.json({ message: \"Payment submitted successfully\" });\n\n  } catch (err) {\n    console.error(\"Error submitting payment:\", err);\n    res.status(500).json({ message: \"Error submitting payment\" });\n  }\n};\n\n// ================= VERIFY PAYMENT (ADMIN ONLY) =================\nexport const verifyPayment = async (req, res) => {\n  const { role } = getIdentityFromReq(req);\n  const { id } = req.params;\n\n  if (role !== \"admin\") {\n    return res.status(403).json({ message: \"Unauthorized\" });\n  }\n\n  try {\n    const pool = await sql.connect(dbConfig);\n    await pool.request()\n      .input(\"PaymentID\", sql.Int, id)\n      .query(\"UPDATE Payments SET Status='Verified', VerifiedDate=GETDATE() WHERE PaymentID=@PaymentID\");\n\n    res.json({ message: \"Payment verified successfully\" });\n\n  } catch (err) {\n    console.error(\"Error verifying payment:\", err);\n    res.status(500).json({ message: \"Error verifying payment\" });\n  }\n};\n"
        }
    ]
}