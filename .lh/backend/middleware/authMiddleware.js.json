{
    "sourceFile": "backend/middleware/authMiddleware.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1763668053706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1763668948105,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,6 +74,8 @@\n         return res.status(403).json({ success: false, message: \"Forbidden: Admin privileges required.\" });\n     }\n     next();\n };\n+\n+\n // Alias for routes\n export const verifyToken = authenticateJWT;\n"
                },
                {
                    "date": 1763695525824,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,78 +4,53 @@\n dotenv.config();\n \n const JWT_SECRET = process.env.JWT_SECRET || \"supersecretkey\";\n \n-/**\n- * Generates a JWT token for the provided payload.\n- */\n+/* ----------------------------------------\n+   Generate Token\n+---------------------------------------- */\n export function generateToken(payload) {\n     return jwt.sign(payload, JWT_SECRET, { expiresIn: \"14d\" });\n }\n \n-/**\n- * Middleware to verify the JWT from the Authorization header and attach user data to req.user.\n- */\n-export const authenticateJWT = (req, res, next) => {\n+/* ----------------------------------------\n+   Verify Token (MAIN middleware)\n+---------------------------------------- */\n+export function verifyToken(req, res, next) {\n     const authHeader = req.headers[\"authorization\"];\n     if (!authHeader) {\n         return res.status(401).json({ success: false, message: \"No token provided.\" });\n     }\n \n-    const parts = authHeader.split(\" \");\n-    if (parts.length !== 2 || parts[0] !== \"Bearer\") {\n-        return res.status(401).json({ success: false, message: \"Invalid token format.\" });\n-    }\n+    const token = authHeader.split(\" \")[1];\n \n-    const token = parts[1];\n-\n     jwt.verify(token, JWT_SECRET, (err, decoded) => {\n         if (err) {\n-            console.error(\"Token verification failed:\", err.message);\n             return res.status(401).json({ success: false, message: \"Invalid or expired token.\" });\n         }\n \n-        /**\n-         * Attach user info:\n-         * - Residents have ResidentID\n-         * - Admin/Security have userId\n-         * - role is always lowercase for middleware checks\n-         */\n         req.user = {\n-            ResidentID: decoded.ResidentID || null,\n-            userId: decoded.userId || null,       // admin/security ID\n+            id: decoded.ResidentID || decoded.userId || null,\n             role: (decoded.role || \"resident\").toLowerCase(),\n             fullName: decoded.fullName || \"\",\n             email: decoded.email || \"\",\n             NationalID: decoded.NationalID || \"\"\n         };\n \n         next();\n     });\n-};\n+}\n \n-/**\n- * Middleware to restrict access to users with the 'admin' role.\n- */\n-export const requireAdmin = (req, res, next) => {\n+/* ----------------------------------------\n+   Only Admin OR Security\n+---------------------------------------- */\n+export function isAdmin(req, res, next) {\n     if (!req.user || !req.user.role) {\n-        return res.status(401).json({ error: \"Access denied. Role information missing.\" });\n+        return res.status(403).json({ error: \"Access denied.\" });\n     }\n-const role = req.user.role;\n-    if (role !== 'admin' && role !=='security') {\n-        return res.status(403).json({ error: \"Access denied. Admin privileges required.\" });\n+\n+    if (req.user.role !== \"admin\" && req.user.role !== \"security\") {\n+        return res.status(403).json({ error: \"Admin/Security access required.\" });\n     }\n \n     next();\n-};\n-export const verifyAdmin = (req, res, next) => {\n-    // 1. Assume verifyToken has already run and attached req.user\n-    if (!req.user || req.user.role !== 'Admin') {\n-        // This sends the 403 status expected by the client.\n-        return res.status(403).json({ success: false, message: \"Forbidden: Admin privileges required.\" });\n-    }\n-    next();\n-};\n-\n-\n-// Alias for routes\n-export const verifyToken = authenticateJWT;\n+}\n"
                },
                {
                    "date": 1763696336648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,56 +1,66 @@\n+// ===============================================\n+// authMiddleware.js (FINAL CLEAN VERSION)\n+// ===============================================\n import jwt from \"jsonwebtoken\";\n import dotenv from \"dotenv\";\n \n dotenv.config();\n \n const JWT_SECRET = process.env.JWT_SECRET || \"supersecretkey\";\n \n-/* ----------------------------------------\n-   Generate Token\n----------------------------------------- */\n+/* ----------------------------------------------\n+   Generate JWT Token\n+---------------------------------------------- */\n export function generateToken(payload) {\n     return jwt.sign(payload, JWT_SECRET, { expiresIn: \"14d\" });\n }\n \n-/* ----------------------------------------\n-   Verify Token (MAIN middleware)\n----------------------------------------- */\n-export function verifyToken(req, res, next) {\n-    const authHeader = req.headers[\"authorization\"];\n-    if (!authHeader) {\n-        return res.status(401).json({ success: false, message: \"No token provided.\" });\n+/* ----------------------------------------------\n+   authenticateJWT\n+   Validates token and attaches decoded user info\n+---------------------------------------------- */\n+export const authenticateJWT = (req, res, next) => {\n+    const authHeader = req.headers.authorization;\n+\n+    if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n+        return res.status(401).json({ message: \"Access denied. No token provided.\" });\n     }\n \n     const token = authHeader.split(\" \")[1];\n \n-    jwt.verify(token, JWT_SECRET, (err, decoded) => {\n-        if (err) {\n-            return res.status(401).json({ success: false, message: \"Invalid or expired token.\" });\n-        }\n+    try {\n+        const decoded = jwt.verify(token, JWT_SECRET);\n \n+        // Standardized user structure\n         req.user = {\n-            id: decoded.ResidentID || decoded.userId || null,\n-            role: (decoded.role || \"resident\").toLowerCase(),\n-            fullName: decoded.fullName || \"\",\n-            email: decoded.email || \"\",\n-            NationalID: decoded.NationalID || \"\"\n+            UserID: decoded.userId || decoded.ResidentID || null,\n+            ResidentID: decoded.ResidentID || null,\n+            Email: decoded.email || \"\",\n+            FullName: decoded.fullName || \"\",\n+            NationalID: decoded.NationalID || \"\",\n+            Role: (decoded.role || decoded.Role || \"resident\").toLowerCase() // ← normalize role\n         };\n \n         next();\n-    });\n-}\n+    } catch (err) {\n+        return res.status(403).json({ message: \"Invalid or expired token.\" });\n+    }\n+};\n \n-/* ----------------------------------------\n-   Only Admin OR Security\n----------------------------------------- */\n-export function isAdmin(req, res, next) {\n-    if (!req.user || !req.user.role) {\n-        return res.status(403).json({ error: \"Access denied.\" });\n+/* ----------------------------------------------\n+   isAdmin\n+   Only Admin OR Security can access certain routes\n+---------------------------------------------- */\n+export const isAdmin = (req, res, next) => {\n+    if (!req.user || !req.user.Role) {\n+        return res.status(403).json({ error: \"Access denied. No role found.\" });\n     }\n \n-    if (req.user.role !== \"admin\" && req.user.role !== \"security\") {\n+    const role = req.user.Role.toLowerCase();\n+\n+    if (role !== \"admin\" && role !== \"security\") {\n         return res.status(403).json({ error: \"Admin/Security access required.\" });\n     }\n \n     next();\n-}\n+};\n"
                },
                {
                    "date": 1763841742734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,10 @@\n             ResidentID: decoded.ResidentID || null,\n             Email: decoded.email || \"\",\n             FullName: decoded.fullName || \"\",\n             NationalID: decoded.NationalID || \"\",\n-            Role: (decoded.role || decoded.Role || \"resident\").toLowerCase() // ← normalize role\n+            role: (decoded.role || decoded.Role || decoded.RoleName || \"resident\").toLowerCase()\n+\n         };\n \n         next();\n     } catch (err) {\n@@ -51,16 +52,47 @@\n    isAdmin\n    Only Admin OR Security can access certain routes\n ---------------------------------------------- */\n export const isAdmin = (req, res, next) => {\n-    if (!req.user || !req.user.Role) {\n-        return res.status(403).json({ error: \"Access denied. No role found.\" });\n+    if (!req.user || !req.user.role) {\n+    return res.status(403).json({ error: \"Access denied. No role found.\" });\n+}\n+\n+const role = req.user.role;\n+    if (role !== \"admin\") {\n+    return res.status(403).json({ error: \"Admin access required.\" });\n+}\n+\n+    next();\n+};\n+\n+\n+/**\n+ * JWT Authentication\n+ */\n+export function authenticateJWT(req, res, next) {\n+    const authHeader = req.headers.authorization;\n+\n+    if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n+        return res.status(401).json({ message: \"No token provided\" });\n     }\n \n-    const role = req.user.Role.toLowerCase();\n+    const token = authHeader.split(\" \")[1];\n \n-    if (role !== \"admin\" && role !== \"security\") {\n-        return res.status(403).json({ error: \"Admin/Security access required.\" });\n+    try {\n+        const decoded = jwt.verify(token, process.env.JWT_SECRET);\n+        req.user = decoded; // stores userId, Email, RoleName\n+        next();\n+    } catch (err) {\n+        return res.status(403).json({ message: \"Invalid or expired token\" });\n     }\n+}\n \n+/**\n+ * ADMIN ONLY ACCESS\n+ */\n+export function adminOnly(req, res, next) {\n+    if (!req.user || req.user.RoleName !== \"Admin\") {\n+        return res.status(403).json({ message: \"Access denied. Admins only.\" });\n+    }\n     next();\n-};\n+}\n"
                },
                {
                    "date": 1763841853125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,74 +1,8 @@\n-// ===============================================\n-// authMiddleware.js (FINAL CLEAN VERSION)\n-// ===============================================\n import jwt from \"jsonwebtoken\";\n-import dotenv from \"dotenv\";\n \n-dotenv.config();\n-\n-const JWT_SECRET = process.env.JWT_SECRET || \"supersecretkey\";\n-\n-/* ----------------------------------------------\n-   Generate JWT Token\n----------------------------------------------- */\n-export function generateToken(payload) {\n-    return jwt.sign(payload, JWT_SECRET, { expiresIn: \"14d\" });\n-}\n-\n-/* ----------------------------------------------\n-   authenticateJWT\n-   Validates token and attaches decoded user info\n----------------------------------------------- */\n-export const authenticateJWT = (req, res, next) => {\n-    const authHeader = req.headers.authorization;\n-\n-    if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n-        return res.status(401).json({ message: \"Access denied. No token provided.\" });\n-    }\n-\n-    const token = authHeader.split(\" \")[1];\n-\n-    try {\n-        const decoded = jwt.verify(token, JWT_SECRET);\n-\n-        // Standardized user structure\n-        req.user = {\n-            UserID: decoded.userId || decoded.ResidentID || null,\n-            ResidentID: decoded.ResidentID || null,\n-            Email: decoded.email || \"\",\n-            FullName: decoded.fullName || \"\",\n-            NationalID: decoded.NationalID || \"\",\n-            role: (decoded.role || decoded.Role || decoded.RoleName || \"resident\").toLowerCase()\n-\n-        };\n-\n-        next();\n-    } catch (err) {\n-        return res.status(403).json({ message: \"Invalid or expired token.\" });\n-    }\n-};\n-\n-/* ----------------------------------------------\n-   isAdmin\n-   Only Admin OR Security can access certain routes\n----------------------------------------------- */\n-export const isAdmin = (req, res, next) => {\n-    if (!req.user || !req.user.role) {\n-    return res.status(403).json({ error: \"Access denied. No role found.\" });\n-}\n-\n-const role = req.user.role;\n-    if (role !== \"admin\") {\n-    return res.status(403).json({ error: \"Admin access required.\" });\n-}\n-\n-    next();\n-};\n-\n-\n /**\n- * JWT Authentication\n+ * JWT Authentication Middleware\n  */\n export function authenticateJWT(req, res, next) {\n     const authHeader = req.headers.authorization;\n \n@@ -79,17 +13,17 @@\n     const token = authHeader.split(\" \")[1];\n \n     try {\n         const decoded = jwt.verify(token, process.env.JWT_SECRET);\n-        req.user = decoded; // stores userId, Email, RoleName\n+        req.user = decoded; // Attach token payload to req.user\n         next();\n     } catch (err) {\n         return res.status(403).json({ message: \"Invalid or expired token\" });\n     }\n }\n \n /**\n- * ADMIN ONLY ACCESS\n+ * Admin-only middleware\n  */\n export function adminOnly(req, res, next) {\n     if (!req.user || req.user.RoleName !== \"Admin\") {\n         return res.status(403).json({ message: \"Access denied. Admins only.\" });\n"
                },
                {
                    "date": 1763841961255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,8 @@\n import jwt from \"jsonwebtoken\";\n-\n+export function generateToken(payload) {\n+    return jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: \"7d\" });\n+}\n /**\n  * JWT Authentication Middleware\n  */\n export function authenticateJWT(req, res, next) {\n"
                },
                {
                    "date": 1763842077964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,19 @@\n import jwt from \"jsonwebtoken\";\n+import dotenv from \"dotenv\";\n+dotenv.config();\n+\n+const JWT_SECRET = process.env.JWT_SECRET || \"supersecretkey\";\n+\n+/**\n+ * Generate JWT token\n+ */\n export function generateToken(payload) {\n-    return jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: \"7d\" });\n+    return jwt.sign(payload, JWT_SECRET, { expiresIn: \"14d\" });\n }\n+\n /**\n- * JWT Authentication Middleware\n+ * JWT authentication middleware\n  */\n export function authenticateJWT(req, res, next) {\n     const authHeader = req.headers.authorization;\n \n@@ -14,10 +23,10 @@\n \n     const token = authHeader.split(\" \")[1];\n \n     try {\n-        const decoded = jwt.verify(token, process.env.JWT_SECRET);\n-        req.user = decoded; // Attach token payload to req.user\n+        const decoded = jwt.verify(token, JWT_SECRET);\n+        req.user = decoded; // Attach user info to req.user\n         next();\n     } catch (err) {\n         return res.status(403).json({ message: \"Invalid or expired token\" });\n     }\n@@ -25,10 +34,10 @@\n \n /**\n  * Admin-only middleware\n  */\n-export function adminOnly(req, res, next) {\n-    if (!req.user || req.user.RoleName !== \"Admin\") {\n+export function isAdmin(req, res, next) {\n+    if (!req.user || (req.user.role || req.user.RoleName)?.toLowerCase() !== \"admin\") {\n         return res.status(403).json({ message: \"Access denied. Admins only.\" });\n     }\n     next();\n }\n"
                },
                {
                    "date": 1763867080395,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,19 +1,23 @@\n+// backend/middleware/authMiddleware.js\n import jwt from \"jsonwebtoken\";\n import dotenv from \"dotenv\";\n dotenv.config();\n \n const JWT_SECRET = process.env.JWT_SECRET || \"supersecretkey\";\n \n /**\n  * Generate JWT token\n+ * @param {Object} payload - user info to encode in the token\n+ * @returns {string} JWT token\n  */\n export function generateToken(payload) {\n     return jwt.sign(payload, JWT_SECRET, { expiresIn: \"14d\" });\n }\n \n /**\n  * JWT authentication middleware\n+ * Verifies token and attaches decoded payload to req.user\n  */\n export function authenticateJWT(req, res, next) {\n     const authHeader = req.headers.authorization;\n \n@@ -24,20 +28,43 @@\n     const token = authHeader.split(\" \")[1];\n \n     try {\n         const decoded = jwt.verify(token, JWT_SECRET);\n-        req.user = decoded; // Attach user info to req.user\n+        req.user = decoded; // attach user info to req.user\n         next();\n     } catch (err) {\n         return res.status(403).json({ message: \"Invalid or expired token\" });\n     }\n }\n \n /**\n  * Admin-only middleware\n+ * Only allows users with role 'admin'\n  */\n export function isAdmin(req, res, next) {\n     if (!req.user || (req.user.role || req.user.RoleName)?.toLowerCase() !== \"admin\") {\n         return res.status(403).json({ message: \"Access denied. Admins only.\" });\n     }\n     next();\n }\n+\n+/**\n+ * Role-based authorization middleware\n+ * Usage: authorizeRole(['admin', 'security'])\n+ * @param {Array<string>} allowedRoles - roles allowed to access route\n+ */\n+export function authorizeRole(allowedRoles = []) {\n+    return (req, res, next) => {\n+        if (!req.user || !req.user.role) {\n+            return res.status(403).json({ message: \"Access denied. No role found.\" });\n+        }\n+\n+        const userRole = req.user.role.toLowerCase();\n+        const allowed = allowedRoles.map(r => r.toLowerCase());\n+\n+        if (!allowed.includes(userRole)) {\n+            return res.status(403).json({ message: `Access denied. Role '${userRole}' not allowed.` });\n+        }\n+\n+        next();\n+    };\n+}\n"
                },
                {
                    "date": 1763867116463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,4 +67,20 @@\n \n         next();\n     };\n }\n+export function authorizeRole(allowedRoles = []) {\n+    return (req, res, next) => {\n+        if (!req.user || !req.user.role) {\n+            return res.status(403).json({ message: \"Access denied. No role found.\" });\n+        }\n+\n+        const userRole = req.user.role.toLowerCase();\n+        const allowed = allowedRoles.map(r => r.toLowerCase());\n+\n+        if (!allowed.includes(userRole)) {\n+            return res.status(403).json({ message: `Access denied. Role '${userRole}' not allowed.` });\n+        }\n+\n+        next();\n+    };\n+}\n"
                },
                {
                    "date": 1763867190574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,20 +67,4 @@\n \n         next();\n     };\n }\n-export function authorizeRole(allowedRoles = []) {\n-    return (req, res, next) => {\n-        if (!req.user || !req.user.role) {\n-            return res.status(403).json({ message: \"Access denied. No role found.\" });\n-        }\n-\n-        const userRole = req.user.role.toLowerCase();\n-        const allowed = allowedRoles.map(r => r.toLowerCase());\n-\n-        if (!allowed.includes(userRole)) {\n-            return res.status(403).json({ message: `Access denied. Role '${userRole}' not allowed.` });\n-        }\n-\n-        next();\n-    };\n-}\n"
                },
                {
                    "date": 1763960655102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,70 +1,53 @@\n-// backend/middleware/authMiddleware.js\n+// backend/middleware/authenticateJWT.js\n import jwt from \"jsonwebtoken\";\n import dotenv from \"dotenv\";\n dotenv.config();\n \n const JWT_SECRET = process.env.JWT_SECRET || \"supersecretkey\";\n \n-/**\n- * Generate JWT token\n- * @param {Object} payload - user info to encode in the token\n- * @returns {string} JWT token\n- */\n-export function generateToken(payload) {\n-    return jwt.sign(payload, JWT_SECRET, { expiresIn: \"14d\" });\n-}\n+const authenticateJWT = (req, res, next) => {\n+    // 1. Handle pre-flight requests\n+    if (req.method === \"OPTIONS\") {\n+        return next();\n+    }\n \n-/**\n- * JWT authentication middleware\n- * Verifies token and attaches decoded payload to req.user\n- */\n-export function authenticateJWT(req, res, next) {\n     const authHeader = req.headers.authorization;\n \n+    // 2. Check for token presence and format\n     if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n-        return res.status(401).json({ message: \"No token provided\" });\n+        return res.status(401).json({ success: false, message: \"No token provided or invalid format\" });\n     }\n \n     const token = authHeader.split(\" \")[1];\n \n     try {\n+        // 3. Synchronous verification for immediate error catching\n         const decoded = jwt.verify(token, JWT_SECRET);\n-        req.user = decoded; // attach user info to req.user\n+\n+        // 4. Attach decoded payload to req.user with defensive assignment\n+        req.user = {\n+            userId: decoded.userId || null,\n+            ResidentID: decoded.ResidentID || null,\n+            // Ensure a role is always present and lowercase\n+            role: (decoded.role || \"resident\").toLowerCase(), \n+            fullName: decoded.fullName || \"\",\n+            email: decoded.email || \"\",\n+            NationalID: decoded.NationalID || \"\",\n+            roleId: decoded.roleId || null,\n+        };\n+\n+        // 5. Continue to the next middleware/route handler\n         next();\n+        \n     } catch (err) {\n-        return res.status(403).json({ message: \"Invalid or expired token\" });\n+        // Handle token errors (expired, invalid signature, malformed)\n+        console.error(\"JWT Verification Error:\", err.message);\n+        return res.status(401).json({ \n+            success: false, \n+            message: \"Invalid or expired token\",\n+            errorType: err.name // Added for better debugging\n+        });\n     }\n-}\n+};\n \n-/**\n- * Admin-only middleware\n- * Only allows users with role 'admin'\n- */\n-export function isAdmin(req, res, next) {\n-    if (!req.user || (req.user.role || req.user.RoleName)?.toLowerCase() !== \"admin\") {\n-        return res.status(403).json({ message: \"Access denied. Admins only.\" });\n-    }\n-    next();\n-}\n-\n-/**\n- * Role-based authorization middleware\n- * Usage: authorizeRole(['admin', 'security'])\n- * @param {Array<string>} allowedRoles - roles allowed to access route\n- */\n-export function authorizeRole(allowedRoles = []) {\n-    return (req, res, next) => {\n-        if (!req.user || !req.user.role) {\n-            return res.status(403).json({ message: \"Access denied. No role found.\" });\n-        }\n-\n-        const userRole = req.user.role.toLowerCase();\n-        const allowed = allowedRoles.map(r => r.toLowerCase());\n-\n-        if (!allowed.includes(userRole)) {\n-            return res.status(403).json({ message: `Access denied. Role '${userRole}' not allowed.` });\n-        }\n-\n-        next();\n-    };\n-}\n+export default authenticateJWT;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763960671510,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,53 +1,70 @@\n-// backend/middleware/authenticateJWT.js\n+// backend/middleware/authMiddleware.js\n import jwt from \"jsonwebtoken\";\n import dotenv from \"dotenv\";\n dotenv.config();\n \n const JWT_SECRET = process.env.JWT_SECRET || \"supersecretkey\";\n \n-const authenticateJWT = (req, res, next) => {\n-    // 1. Handle pre-flight requests\n-    if (req.method === \"OPTIONS\") {\n-        return next();\n-    }\n+/**\n+ * Generate JWT token\n+ * @param {Object} payload - user info to encode in the token\n+ * @returns {string} JWT token\n+ */\n+export function generateToken(payload) {\n+    return jwt.sign(payload, JWT_SECRET, { expiresIn: \"14d\" });\n+}\n \n+/**\n+ * JWT authentication middleware\n+ * Verifies token and attaches decoded payload to req.user\n+ */\n+export function authenticateJWT(req, res, next) {\n     const authHeader = req.headers.authorization;\n \n-    // 2. Check for token presence and format\n     if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n-        return res.status(401).json({ success: false, message: \"No token provided or invalid format\" });\n+        return res.status(401).json({ message: \"No token provided\" });\n     }\n \n     const token = authHeader.split(\" \")[1];\n \n     try {\n-        // 3. Synchronous verification for immediate error catching\n         const decoded = jwt.verify(token, JWT_SECRET);\n-\n-        // 4. Attach decoded payload to req.user with defensive assignment\n-        req.user = {\n-            userId: decoded.userId || null,\n-            ResidentID: decoded.ResidentID || null,\n-            // Ensure a role is always present and lowercase\n-            role: (decoded.role || \"resident\").toLowerCase(), \n-            fullName: decoded.fullName || \"\",\n-            email: decoded.email || \"\",\n-            NationalID: decoded.NationalID || \"\",\n-            roleId: decoded.roleId || null,\n-        };\n-\n\\ No newline at end of file\n-        // 5. Continue to the next middleware/route handler\n+        req.user = decoded; // attach user info to req.user\n         next();\n-        \n     } catch (err) {\n-        // Handle token errors (expired, invalid signature, malformed)\n-        console.error(\"JWT Verification Error:\", err.message);\n-        return res.status(401).json({ \n-            success: false, \n-            message: \"Invalid or expired token\",\n-            errorType: err.name // Added for better debugging\n-        });\n+        return res.status(403).json({ message: \"Invalid or expired token\" });\n     }\n-};\n+}\n \n-export default authenticateJWT;\n+/**\n+ * Admin-only middleware\n+ * Only allows users with role 'admin'\n+ */\n+export function isAdmin(req, res, next) {\n+    if (!req.user || (req.user.role || req.user.RoleName)?.toLowerCase() !== \"admin\") {\n+        return res.status(403).json({ message: \"Access denied. Admins only.\" });\n+    }\n+    next();\n+}\n+\n+/**\n+ * Role-based authorization middleware\n+ * Usage: authorizeRole(['admin', 'security'])\n+ * @param {Array<string>} allowedRoles - roles allowed to access route\n+ */\n+export function authorizeRole(allowedRoles = []) {\n+    return (req, res, next) => {\n+        if (!req.user || !req.user.role) {\n+            return res.status(403).json({ message: \"Access denied. No role found.\" });\n+        }\n+\n+        const userRole = req.user.role.toLowerCase();\n+        const allowed = allowedRoles.map(r => r.toLowerCase());\n+\n+        if (!allowed.includes(userRole)) {\n+            return res.status(403).json({ message: `Access denied. Role '${userRole}' not allowed.` });\n+        }\n+\n+        next();\n+    };\n+}\n"
                },
                {
                    "date": 1763969824790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,70 +1,45 @@\n-// backend/middleware/authMiddleware.js\n import jwt from \"jsonwebtoken\";\n import dotenv from \"dotenv\";\n dotenv.config();\n \n const JWT_SECRET = process.env.JWT_SECRET || \"supersecretkey\";\n \n-/**\n- * Generate JWT token\n- * @param {Object} payload - user info to encode in the token\n- * @returns {string} JWT token\n- */\n+// Generate JWT token\n export function generateToken(payload) {\n-    return jwt.sign(payload, JWT_SECRET, { expiresIn: \"14d\" });\n+  return jwt.sign(payload, JWT_SECRET, { expiresIn: \"14d\" });\n }\n \n-/**\n- * JWT authentication middleware\n- * Verifies token and attaches decoded payload to req.user\n- */\n+// Verify JWT middleware\n export function authenticateJWT(req, res, next) {\n-    const authHeader = req.headers.authorization;\n+  const authHeader = req.headers.authorization;\n+  if (!authHeader || !authHeader.startsWith(\"Bearer \"))\n+    return res.status(401).json({ message: \"No token provided\" });\n \n-    if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n-        return res.status(401).json({ message: \"No token provided\" });\n-    }\n-\n-    const token = authHeader.split(\" \")[1];\n-\n-    try {\n-        const decoded = jwt.verify(token, JWT_SECRET);\n-        req.user = decoded; // attach user info to req.user\n-        next();\n-    } catch (err) {\n-        return res.status(403).json({ message: \"Invalid or expired token\" });\n-    }\n+  const token = authHeader.split(\" \")[1];\n+  try {\n+    const decoded = jwt.verify(token, JWT_SECRET);\n+    req.user = decoded;\n+    next();\n+  } catch (err) {\n+    return res.status(403).json({ message: \"Invalid or expired token\" });\n+  }\n }\n \n-/**\n- * Admin-only middleware\n- * Only allows users with role 'admin'\n- */\n+// Admin-only middleware\n export function isAdmin(req, res, next) {\n-    if (!req.user || (req.user.role || req.user.RoleName)?.toLowerCase() !== \"admin\") {\n-        return res.status(403).json({ message: \"Access denied. Admins only.\" });\n-    }\n-    next();\n+  const role = (req.user.role || req.user.RoleName || \"\").toLowerCase();\n+  if (role !== \"admin\") return res.status(403).json({ message: \"Access denied. Admins only.\" });\n+  next();\n }\n \n-/**\n- * Role-based authorization middleware\n- * Usage: authorizeRole(['admin', 'security'])\n- * @param {Array<string>} allowedRoles - roles allowed to access route\n- */\n+// Role-based authorization\n export function authorizeRole(allowedRoles = []) {\n-    return (req, res, next) => {\n-        if (!req.user || !req.user.role) {\n-            return res.status(403).json({ message: \"Access denied. No role found.\" });\n-        }\n-\n-        const userRole = req.user.role.toLowerCase();\n-        const allowed = allowedRoles.map(r => r.toLowerCase());\n-\n-        if (!allowed.includes(userRole)) {\n-            return res.status(403).json({ message: `Access denied. Role '${userRole}' not allowed.` });\n-        }\n-\n-        next();\n-    };\n+  return (req, res, next) => {\n+    const userRole = (req.user.role || \"\").toLowerCase();\n+    const allowed = allowedRoles.map(r => r.toLowerCase());\n+    if (!allowed.includes(userRole)) {\n+      return res.status(403).json({ message: `Access denied. Role '${userRole}' not allowed.` });\n+    }\n+    next();\n+  };\n }\n"
                }
            ],
            "date": 1763668053706,
            "name": "Commit-0",
            "content": "import jwt from \"jsonwebtoken\";\nimport dotenv from \"dotenv\";\n\ndotenv.config();\n\nconst JWT_SECRET = process.env.JWT_SECRET || \"supersecretkey\";\n\n/**\n * Generates a JWT token for the provided payload.\n */\nexport function generateToken(payload) {\n    return jwt.sign(payload, JWT_SECRET, { expiresIn: \"14d\" });\n}\n\n/**\n * Middleware to verify the JWT from the Authorization header and attach user data to req.user.\n */\nexport const authenticateJWT = (req, res, next) => {\n    const authHeader = req.headers[\"authorization\"];\n    if (!authHeader) {\n        return res.status(401).json({ success: false, message: \"No token provided.\" });\n    }\n\n    const parts = authHeader.split(\" \");\n    if (parts.length !== 2 || parts[0] !== \"Bearer\") {\n        return res.status(401).json({ success: false, message: \"Invalid token format.\" });\n    }\n\n    const token = parts[1];\n\n    jwt.verify(token, JWT_SECRET, (err, decoded) => {\n        if (err) {\n            console.error(\"Token verification failed:\", err.message);\n            return res.status(401).json({ success: false, message: \"Invalid or expired token.\" });\n        }\n\n        /**\n         * Attach user info:\n         * - Residents have ResidentID\n         * - Admin/Security have userId\n         * - role is always lowercase for middleware checks\n         */\n        req.user = {\n            ResidentID: decoded.ResidentID || null,\n            userId: decoded.userId || null,       // admin/security ID\n            role: (decoded.role || \"resident\").toLowerCase(),\n            fullName: decoded.fullName || \"\",\n            email: decoded.email || \"\",\n            NationalID: decoded.NationalID || \"\"\n        };\n\n        next();\n    });\n};\n\n/**\n * Middleware to restrict access to users with the 'admin' role.\n */\nexport const requireAdmin = (req, res, next) => {\n    if (!req.user || !req.user.role) {\n        return res.status(401).json({ error: \"Access denied. Role information missing.\" });\n    }\nconst role = req.user.role;\n    if (role !== 'admin' && role !=='security') {\n        return res.status(403).json({ error: \"Access denied. Admin privileges required.\" });\n    }\n\n    next();\n};\nexport const verifyAdmin = (req, res, next) => {\n    // 1. Assume verifyToken has already run and attached req.user\n    if (!req.user || req.user.role !== 'Admin') {\n        // This sends the 403 status expected by the client.\n        return res.status(403).json({ success: false, message: \"Forbidden: Admin privileges required.\" });\n    }\n    next();\n};\n// Alias for routes\nexport const verifyToken = authenticateJWT;\n"
        }
    ]
}