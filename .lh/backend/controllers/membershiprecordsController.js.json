{
    "sourceFile": "backend/controllers/membershiprecordsController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1763779444902,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1763779582430,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,16 @@\n+The code provided is already complete and correctly integrates the new `getPendingRequests` and `getApprovedResidents` functions into the existing set of controller functions for the `membershiprecordsController.js` file.\r\n+\r\n+Here is the entire, assembled, and corrected code for `backend/controllers/membershiprecordsController.js`:\r\n+\r\n+```javascript\r\n // ==========================================\r\n // backend/controllers/membershiprecordsController.js\r\n // ==========================================\r\n import sql from \"mssql\";\r\n import dbConfig from \"../config/dbConfig.js\";\r\n \r\n // â¸ï¸ GET PENDING MEMBERSHIP REQUESTS (used to populate top table)\r\n-/**\r\n- * Fetches all membership requests that currently have a 'Pending' status\r\n- * from the MembershipRequests table.\r\n- */\r\n export const getPendingRequests = async (req, res) => {\r\n   try {\r\n     const pool = await sql.connect(dbConfig);\r\n     // Fetch only pending requests from the MembershipRequests table\r\n@@ -19,20 +20,17 @@\n       FROM MembershipRequests\r\n       WHERE Status = 'Pending'\r\n       ORDER BY RequestedAt DESC\r\n     `);\r\n-    // The frontend expects an array of requests directly\r\n+    // Note: The frontend expects an array of requests directly\r\n     res.json(result.recordset);\r\n   } catch (error) {\r\n     console.error(\"âŒ Error fetching pending requests:\", error);\r\n     res.status(500).json({ success: false, message: error.message });\r\n   }\r\n };\r\n \r\n // ðŸ‘ GET APPROVED RESIDENTS (used to populate bottom table)\r\n-/**\r\n- * Fetches all approved membership records from the MembershipRecords table.\r\n- */\r\n export const getApprovedResidents = async (req, res) => {\r\n   try {\r\n     const pool = await sql.connect(dbConfig);\r\n     // Fetch only approved records from the MembershipRecords table\r\n@@ -42,22 +40,17 @@\n       FROM MembershipRecords\r\n       WHERE Status = 'Approved'\r\n       ORDER BY ResidentName ASC\r\n     `);\r\n-    // The frontend expects an array of residents directly\r\n+    // Note: The frontend expects an array of residents directly\r\n     res.json(result.recordset);\r\n   } catch (error) {\r\n     console.error(\"âŒ Error fetching approved residents:\", error);\r\n     res.status(500).json({ success: false, message: error.message });\r\n   }\r\n };\r\n \r\n // ðŸŸ¢ SYNC MEMBERSHIP RECORDS (requests â†’ records)\r\n-/**\r\n- * Synchronizes pending requests from MembershipRequests into MembershipRecords.\r\n- * This is typically a background or manual process to ensure the records table\r\n- * has entries for pending items before they are approved/rejected.\r\n- */\r\n export const syncMembershipRecords = async (req, res) => {\r\n   try {\r\n     const pool = await sql.connect(dbConfig);\r\n \r\n@@ -72,9 +65,9 @@\n     const requests = requestsResult.recordset;\r\n     let syncCount = { inserted: 0, skipped: 0 };\r\n \r\n     for (const r of requests) {\r\n-      // Check if record already exists in MembershipRecords\r\n+      // Skip if record already exists\r\n       const existing = await pool\r\n         .request()\r\n         .input(\"RequestID\", sql.Int, r.RequestID)\r\n         .query(\"SELECT 1 FROM MembershipRecords WHERE RequestID=@RequestID\");\r\n@@ -113,11 +106,8 @@\n   }\r\n };\r\n \r\n // ðŸ“‹ GET ALL MEMBERSHIP RECORDS\r\n-/**\r\n- * Fetches all records from the MembershipRecords table (used for general admin review).\r\n- */\r\n export const getAllMembershipRecords = async (req, res) => {\r\n   try {\r\n     const pool = await sql.connect(dbConfig);\r\n     const result = await pool.request().query(\"SELECT * FROM MembershipRecords ORDER BY RequestedAt DESC\");\r\n@@ -127,11 +117,8 @@\n   }\r\n };\r\n \r\n // âœ… APPROVE MEMBERSHIP RECORD\r\n-/**\r\n- * Updates the Status to 'Approved' for a request in BOTH MembershipRecords and MembershipRequests.\r\n- */\r\n export const approveMembershipRecord = async (req, res) => {\r\n   const { id } = req.params;\r\n   try {\r\n     const pool = await sql.connect(dbConfig);\r\n@@ -147,11 +134,8 @@\n   }\r\n };\r\n \r\n // âŒ REJECT MEMBERSHIP RECORD\r\n-/**\r\n- * Updates the Status to 'Rejected' for a request in BOTH MembershipRecords and MembershipRequests.\r\n- */\r\n export const rejectMembershipRecord = async (req, res) => {\r\n   const { id } = req.params;\r\n   try {\r\n     const pool = await sql.connect(dbConfig);\r\n@@ -167,11 +151,8 @@\n   }\r\n };\r\n \r\n // ðŸ—‘ï¸ DELETE MEMBERSHIP RECORD\r\n-/**\r\n- * Deletes a record from the MembershipRecords table (note: does not affect MembershipRequests).\r\n- */\r\n export const deleteMembershipRecord = async (req, res) => {\r\n   const { id } = req.params;\r\n   try {\r\n     const pool = await sql.connect(dbConfig);\r\n@@ -179,5 +160,6 @@\n     res.json({ success: true, message: `Record ${id} deleted` });\r\n   } catch (error) {\r\n     res.status(500).json({ success: false, message: error.message });\r\n   }\r\n-};\n\\ No newline at end of file\n+};\r\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763779624345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,55 +1,10 @@\n-The code provided is already complete and correctly integrates the new `getPendingRequests` and `getApprovedResidents` functions into the existing set of controller functions for the `membershiprecordsController.js` file.\r\n-\r\n-Here is the entire, assembled, and corrected code for `backend/controllers/membershiprecordsController.js`:\r\n-\r\n-```javascript\r\n // ==========================================\r\n // backend/controllers/membershiprecordsController.js\r\n // ==========================================\r\n import sql from \"mssql\";\r\n import dbConfig from \"../config/dbConfig.js\";\r\n \r\n-// â¸ï¸ GET PENDING MEMBERSHIP REQUESTS (used to populate top table)\r\n-export const getPendingRequests = async (req, res) => {\r\n-  try {\r\n-    const pool = await sql.connect(dbConfig);\r\n-    // Fetch only pending requests from the MembershipRequests table\r\n-    const result = await pool.request().query(`\r\n-      SELECT RequestID as id, ResidentName, NationalID, PhoneNumber, Email,\r\n-             HouseNumber, CourtName, RoleName, Status, RequestedAt\r\n-      FROM MembershipRequests\r\n-      WHERE Status = 'Pending'\r\n-      ORDER BY RequestedAt DESC\r\n-    `);\r\n-    // Note: The frontend expects an array of requests directly\r\n-    res.json(result.recordset);\r\n-  } catch (error) {\r\n-    console.error(\"âŒ Error fetching pending requests:\", error);\r\n-    res.status(500).json({ success: false, message: error.message });\r\n-  }\r\n-};\r\n-\r\n-// ðŸ‘ GET APPROVED RESIDENTS (used to populate bottom table)\r\n-export const getApprovedResidents = async (req, res) => {\r\n-  try {\r\n-    const pool = await sql.connect(dbConfig);\r\n-    // Fetch only approved records from the MembershipRecords table\r\n-    const result = await pool.request().query(`\r\n-      SELECT ResidentName, NationalID, PhoneNumber, Email,\r\n-             HouseNumber, CourtName, RoleName\r\n-      FROM MembershipRecords\r\n-      WHERE Status = 'Approved'\r\n-      ORDER BY ResidentName ASC\r\n-    `);\r\n-    // Note: The frontend expects an array of residents directly\r\n-    res.json(result.recordset);\r\n-  } catch (error) {\r\n-    console.error(\"âŒ Error fetching approved residents:\", error);\r\n-    res.status(500).json({ success: false, message: error.message });\r\n-  }\r\n-};\r\n-\r\n // ðŸŸ¢ SYNC MEMBERSHIP RECORDS (requests â†’ records)\r\n export const syncMembershipRecords = async (req, res) => {\r\n   try {\r\n     const pool = await sql.connect(dbConfig);\r\n@@ -161,5 +116,4 @@\n   } catch (error) {\r\n     res.status(500).json({ success: false, message: error.message });\r\n   }\r\n };\r\n-```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763779845326,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,4 +116,54 @@\n   } catch (error) {\r\n     res.status(500).json({ success: false, message: error.message });\r\n   }\r\n };\r\n+// ==========================================\r\n+// backend/controllers/membershiprecordsController.js - ADDITIONS\r\n+// ==========================================\r\n+\r\n+// ... existing imports ...\r\n+\r\n+// â¸ï¸ GET PENDING MEMBERSHIP REQUESTS (used to populate top table)\r\n+export const getPendingRequests = async (req, res) => {\r\n+  try {\r\n+    const pool = await sql.connect(dbConfig);\r\n+    // Fetch only pending requests from the original Requests table\r\n+    const result = await pool.request().query(`\r\n+      SELECT RequestID as id, ResidentName, NationalID, PhoneNumber, Email,\r\n+             HouseNumber, CourtName, RoleName, Status, RequestedAt\r\n+      FROM MembershipRequests\r\n+      WHERE Status = 'Pending'\r\n+      ORDER BY RequestedAt DESC\r\n+    `);\r\n+    // Note: The frontend expects an array of requests directly (as per loadPendingRequests logic)\r\n+    res.json(result.recordset);\r\n+  } catch (error) {\r\n+    console.error(\"âŒ Error fetching pending requests:\", error);\r\n+    res.status(500).json({ success: false, message: error.message });\r\n+  }\r\n+};\r\n+\r\n+// ðŸ‘ GET APPROVED RESIDENTS (used to populate bottom table)\r\n+export const getApprovedResidents = async (req, res) => {\r\n+  try {\r\n+    const pool = await sql.connect(dbConfig);\r\n+    // Fetch only approved records from the MembershipRecords table (or a Residents table if you have one)\r\n+    // We'll use MembershipRecords where Status='Approved' for simplicity, as per the flow description.\r\n+    const result = await pool.request().query(`\r\n+      SELECT ResidentName, NationalID, PhoneNumber, Email,\r\n+             HouseNumber, CourtName, RoleName\r\n+      FROM MembershipRecords\r\n+      WHERE Status = 'Approved'\r\n+      ORDER BY ResidentName ASC\r\n+    `);\r\n+    // Note: The frontend expects an array of residents directly (as per loadApprovedResidents logic)\r\n+    res.json(result.recordset);\r\n+  } catch (error) {\r\n+    console.error(\"âŒ Error fetching approved residents:\", error);\r\n+    res.status(500).json({ success: false, message: error.message });\r\n+  }\r\n+};\r\n+\r\n+// ... existing controller functions (syncMembershipRecords, approveMembershipRecord, etc.) ...\r\n+// Note: The existing approveMembershipRecord, rejectMembershipRecord, and deleteMembershipRecord \r\n+// correctly update BOTH MembershipRecords AND MembershipRequests, which is the desired behavior!\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763964424510,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,169 +1,66 @@\n-// ==========================================\r\n-// backend/controllers/membershiprecordsController.js\r\n-// ==========================================\r\n-import sql from \"mssql\";\r\n-import dbConfig from \"../config/dbConfig.js\";\r\n+// controllers/membershipController.js\r\n \r\n-// ðŸŸ¢ SYNC MEMBERSHIP RECORDS (requests â†’ records)\r\n-export const syncMembershipRecords = async (req, res) => {\r\n-  try {\r\n-    const pool = await sql.connect(dbConfig);\r\n+// Assuming you use the 'mssql' library for SQL Server connection\r\n+const sql = require('mssql'); \r\n+// Replace with your actual database configuration file\r\n+const dbConfig = require('../config/dbConfig'); \r\n \r\n-    // Fetch all pending membership requests\r\n-    const requestsResult = await pool.request().query(`\r\n-      SELECT RequestID, ResidentName, NationalID, PhoneNumber, Email,\r\n-             HouseNumber, CourtName, RoleName, Status, RequestedAt\r\n-      FROM MembershipRequests\r\n-      WHERE Status = 'Pending'\r\n-    `);\r\n+// Utility to wrap async functions and handle errors automatically\r\n+const asyncHandler = fn => (req, res, next) => {\r\n+    Promise.resolve(fn(req, res, next)).catch(next);\r\n+};\r\n \r\n-    const requests = requestsResult.recordset;\r\n-    let syncCount = { inserted: 0, skipped: 0 };\r\n+/**\r\n+ * @desc Get resident membership records (top 1000)\r\n+ * @route GET /api/residents/records\r\n+ * @access Private\r\n+ */\r\n+exports.getResidentRecords = asyncHandler(async (req, res) => {\r\n+    // ðŸ”‘ Step 1: Permission Check\r\n+    // Customize this based on the roles defined in your JWT payload (req.user)\r\n+    if (req.user.role !== 'Admin' && req.user.role !== 'MembershipManager') {\r\n+        return res.status(403).json({ message: 'Access denied. Insufficient privileges.' });\r\n+    }\r\n \r\n-    for (const r of requests) {\r\n-      // Skip if record already exists\r\n-      const existing = await pool\r\n-        .request()\r\n-        .input(\"RequestID\", sql.Int, r.RequestID)\r\n-        .query(\"SELECT 1 FROM MembershipRecords WHERE RequestID=@RequestID\");\r\n+    // ðŸ”‘ Step 2: Define the SQL Query\r\n+    const sqlQuery = `\r\n+        SELECT TOP (1000) \r\n+            [ResidentName], \r\n+            [NationalID], \r\n+            [PhoneNumber], \r\n+            [Email], \r\n+            [HouseNumber], \r\n+            [CourtName], \r\n+            [Status], \r\n+            [RequestedAt], \r\n+            [Action], \r\n+            [RequestID], \r\n+            [RoleName]\r\n+        FROM [EstateAccessManagementSystem].[dbo].[MembershipRecords_Backup]\r\n+        ORDER BY RequestedAt DESC; -- Optional: Order by most recent requests\r\n+    `;\r\n \r\n-      if (existing.recordset.length > 0) {\r\n-        syncCount.skipped++;\r\n-        continue;\r\n-      }\r\n+    let pool;\r\n+    try {\r\n+        // ðŸ”‘ Step 3: Establish connection and execute query\r\n+        pool = await sql.connect(dbConfig);\r\n+        const result = await pool.request().query(sqlQuery);\r\n+        \r\n+        const records = result.recordset;\r\n \r\n-      // Insert into MembershipRecords\r\n-      await pool\r\n-        .request()\r\n-        .input(\"RequestID\", sql.Int, r.RequestID)\r\n-        .input(\"ResidentName\", sql.NVarChar, r.ResidentName)\r\n-        .input(\"NationalID\", sql.NVarChar, r.NationalID)\r\n-        .input(\"PhoneNumber\", sql.NVarChar, r.PhoneNumber)\r\n-        .input(\"Email\", sql.NVarChar, r.Email)\r\n-        .input(\"HouseNumber\", sql.NVarChar, r.HouseNumber)\r\n-        .input(\"CourtName\", sql.NVarChar, r.CourtName)\r\n-        .input(\"RoleName\", sql.NVarChar, r.RoleName)\r\n-        .input(\"Status\", sql.NVarChar, r.Status)\r\n-        .input(\"RequestedAt\", sql.DateTime, r.RequestedAt)\r\n-        .query(`\r\n-          INSERT INTO MembershipRecords\r\n-          (RequestID, ResidentName, NationalID, PhoneNumber, Email, HouseNumber, CourtName, RoleName, Status, RequestedAt)\r\n-          VALUES (@RequestID,@ResidentName,@NationalID,@PhoneNumber,@Email,@HouseNumber,@CourtName,@RoleName,@Status,@RequestedAt)\r\n-        `);\r\n+        // ðŸ”‘ Step 4: Send the data\r\n+        res.status(200).json(records);\r\n \r\n-      syncCount.inserted++;\r\n+    } catch (error) {\r\n+        console.error('Database query failed:', error);\r\n+        // Send a generic error message back to the client\r\n+        res.status(500).json({ \r\n+            message: 'Failed to retrieve membership records due to a server error.'\r\n+        });\r\n+    } finally {\r\n+        // ðŸ”‘ Step 5: Close the connection (or release the pool)\r\n+        if (pool) {\r\n+            pool.close();\r\n+        }\r\n     }\r\n-\r\n-    res.json({ success: true, message: \"Sync completed\", syncCount });\r\n-  } catch (error) {\r\n-    console.error(\"âŒ Sync error:\", error);\r\n-    res.status(500).json({ success: false, message: `Sync failed: ${error.message}` });\r\n-  }\r\n-};\r\n-\r\n-// ðŸ“‹ GET ALL MEMBERSHIP RECORDS\r\n-export const getAllMembershipRecords = async (req, res) => {\r\n-  try {\r\n-    const pool = await sql.connect(dbConfig);\r\n-    const result = await pool.request().query(\"SELECT * FROM MembershipRecords ORDER BY RequestedAt DESC\");\r\n-    res.json({ success: true, records: result.recordset });\r\n-  } catch (error) {\r\n-    res.status(500).json({ success: false, message: error.message });\r\n-  }\r\n-};\r\n-\r\n-// âœ… APPROVE MEMBERSHIP RECORD\r\n-export const approveMembershipRecord = async (req, res) => {\r\n-  const { id } = req.params;\r\n-  try {\r\n-    const pool = await sql.connect(dbConfig);\r\n-\r\n-    await pool.request().input(\"RequestID\", sql.Int, id).query(`\r\n-      UPDATE MembershipRecords SET Status='Approved' WHERE RequestID=@RequestID;\r\n-      UPDATE MembershipRequests SET Status='Approved' WHERE RequestID=@RequestID;\r\n-    `);\r\n-\r\n-    res.json({ success: true, message: `Record ${id} approved` });\r\n-  } catch (error) {\r\n-    res.status(500).json({ success: false, message: error.message });\r\n-  }\r\n-};\r\n-\r\n-// âŒ REJECT MEMBERSHIP RECORD\r\n-export const rejectMembershipRecord = async (req, res) => {\r\n-  const { id } = req.params;\r\n-  try {\r\n-    const pool = await sql.connect(dbConfig);\r\n-\r\n-    await pool.request().input(\"RequestID\", sql.Int, id).query(`\r\n-      UPDATE MembershipRecords SET Status='Rejected' WHERE RequestID=@RequestID;\r\n-      UPDATE MembershipRequests SET Status='Rejected' WHERE RequestID=@RequestID;\r\n-    `);\r\n-\r\n-    res.json({ success: true, message: `Record ${id} rejected` });\r\n-  } catch (error) {\r\n-    res.status(500).json({ success: false, message: error.message });\r\n-  }\r\n-};\r\n-\r\n-// ðŸ—‘ï¸ DELETE MEMBERSHIP RECORD\r\n-export const deleteMembershipRecord = async (req, res) => {\r\n-  const { id } = req.params;\r\n-  try {\r\n\\ No newline at end of file\n-    const pool = await sql.connect(dbConfig);\r\n-    await pool.request().input(\"RequestID\", sql.Int, id).query(\"DELETE FROM MembershipRecords WHERE RequestID=@RequestID\");\r\n-    res.json({ success: true, message: `Record ${id} deleted` });\r\n-  } catch (error) {\r\n-    res.status(500).json({ success: false, message: error.message });\r\n-  }\r\n-};\r\n-// ==========================================\r\n-// backend/controllers/membershiprecordsController.js - ADDITIONS\r\n-// ==========================================\r\n-\r\n-// ... existing imports ...\r\n-\r\n-// â¸ï¸ GET PENDING MEMBERSHIP REQUESTS (used to populate top table)\r\n-export const getPendingRequests = async (req, res) => {\r\n-  try {\r\n-    const pool = await sql.connect(dbConfig);\r\n-    // Fetch only pending requests from the original Requests table\r\n-    const result = await pool.request().query(`\r\n-      SELECT RequestID as id, ResidentName, NationalID, PhoneNumber, Email,\r\n-             HouseNumber, CourtName, RoleName, Status, RequestedAt\r\n-      FROM MembershipRequests\r\n-      WHERE Status = 'Pending'\r\n-      ORDER BY RequestedAt DESC\r\n-    `);\r\n-    // Note: The frontend expects an array of requests directly (as per loadPendingRequests logic)\r\n-    res.json(result.recordset);\r\n-  } catch (error) {\r\n-    console.error(\"âŒ Error fetching pending requests:\", error);\r\n-    res.status(500).json({ success: false, message: error.message });\r\n-  }\r\n-};\r\n-\r\n-// ðŸ‘ GET APPROVED RESIDENTS (used to populate bottom table)\r\n-export const getApprovedResidents = async (req, res) => {\r\n-  try {\r\n-    const pool = await sql.connect(dbConfig);\r\n-    // Fetch only approved records from the MembershipRecords table (or a Residents table if you have one)\r\n-    // We'll use MembershipRecords where Status='Approved' for simplicity, as per the flow description.\r\n-    const result = await pool.request().query(`\r\n-      SELECT ResidentName, NationalID, PhoneNumber, Email,\r\n-             HouseNumber, CourtName, RoleName\r\n-      FROM MembershipRecords\r\n-      WHERE Status = 'Approved'\r\n-      ORDER BY ResidentName ASC\r\n-    `);\r\n-    // Note: The frontend expects an array of residents directly (as per loadApprovedResidents logic)\r\n-    res.json(result.recordset);\r\n-  } catch (error) {\r\n-    console.error(\"âŒ Error fetching approved residents:\", error);\r\n-    res.status(500).json({ success: false, message: error.message });\r\n-  }\r\n-};\r\n-\r\n-// ... existing controller functions (syncMembershipRecords, approveMembershipRecord, etc.) ...\r\n-// Note: The existing approveMembershipRecord, rejectMembershipRecord, and deleteMembershipRecord \r\n-// correctly update BOTH MembershipRecords AND MembershipRequests, which is the desired behavior!\n+});\n\\ No newline at end of file\n"
                }
            ],
            "date": 1763779444902,
            "name": "Commit-0",
            "content": "// ==========================================\r\n// backend/controllers/membershiprecordsController.js\r\n// ==========================================\r\nimport sql from \"mssql\";\r\nimport dbConfig from \"../config/dbConfig.js\";\r\n\r\n// â¸ï¸ GET PENDING MEMBERSHIP REQUESTS (used to populate top table)\r\n/**\r\n * Fetches all membership requests that currently have a 'Pending' status\r\n * from the MembershipRequests table.\r\n */\r\nexport const getPendingRequests = async (req, res) => {\r\n  try {\r\n    const pool = await sql.connect(dbConfig);\r\n    // Fetch only pending requests from the MembershipRequests table\r\n    const result = await pool.request().query(`\r\n      SELECT RequestID as id, ResidentName, NationalID, PhoneNumber, Email,\r\n             HouseNumber, CourtName, RoleName, Status, RequestedAt\r\n      FROM MembershipRequests\r\n      WHERE Status = 'Pending'\r\n      ORDER BY RequestedAt DESC\r\n    `);\r\n    // The frontend expects an array of requests directly\r\n    res.json(result.recordset);\r\n  } catch (error) {\r\n    console.error(\"âŒ Error fetching pending requests:\", error);\r\n    res.status(500).json({ success: false, message: error.message });\r\n  }\r\n};\r\n\r\n// ðŸ‘ GET APPROVED RESIDENTS (used to populate bottom table)\r\n/**\r\n * Fetches all approved membership records from the MembershipRecords table.\r\n */\r\nexport const getApprovedResidents = async (req, res) => {\r\n  try {\r\n    const pool = await sql.connect(dbConfig);\r\n    // Fetch only approved records from the MembershipRecords table\r\n    const result = await pool.request().query(`\r\n      SELECT ResidentName, NationalID, PhoneNumber, Email,\r\n             HouseNumber, CourtName, RoleName\r\n      FROM MembershipRecords\r\n      WHERE Status = 'Approved'\r\n      ORDER BY ResidentName ASC\r\n    `);\r\n    // The frontend expects an array of residents directly\r\n    res.json(result.recordset);\r\n  } catch (error) {\r\n    console.error(\"âŒ Error fetching approved residents:\", error);\r\n    res.status(500).json({ success: false, message: error.message });\r\n  }\r\n};\r\n\r\n// ðŸŸ¢ SYNC MEMBERSHIP RECORDS (requests â†’ records)\r\n/**\r\n * Synchronizes pending requests from MembershipRequests into MembershipRecords.\r\n * This is typically a background or manual process to ensure the records table\r\n * has entries for pending items before they are approved/rejected.\r\n */\r\nexport const syncMembershipRecords = async (req, res) => {\r\n  try {\r\n    const pool = await sql.connect(dbConfig);\r\n\r\n    // Fetch all pending membership requests\r\n    const requestsResult = await pool.request().query(`\r\n      SELECT RequestID, ResidentName, NationalID, PhoneNumber, Email,\r\n             HouseNumber, CourtName, RoleName, Status, RequestedAt\r\n      FROM MembershipRequests\r\n      WHERE Status = 'Pending'\r\n    `);\r\n\r\n    const requests = requestsResult.recordset;\r\n    let syncCount = { inserted: 0, skipped: 0 };\r\n\r\n    for (const r of requests) {\r\n      // Check if record already exists in MembershipRecords\r\n      const existing = await pool\r\n        .request()\r\n        .input(\"RequestID\", sql.Int, r.RequestID)\r\n        .query(\"SELECT 1 FROM MembershipRecords WHERE RequestID=@RequestID\");\r\n\r\n      if (existing.recordset.length > 0) {\r\n        syncCount.skipped++;\r\n        continue;\r\n      }\r\n\r\n      // Insert into MembershipRecords\r\n      await pool\r\n        .request()\r\n        .input(\"RequestID\", sql.Int, r.RequestID)\r\n        .input(\"ResidentName\", sql.NVarChar, r.ResidentName)\r\n        .input(\"NationalID\", sql.NVarChar, r.NationalID)\r\n        .input(\"PhoneNumber\", sql.NVarChar, r.PhoneNumber)\r\n        .input(\"Email\", sql.NVarChar, r.Email)\r\n        .input(\"HouseNumber\", sql.NVarChar, r.HouseNumber)\r\n        .input(\"CourtName\", sql.NVarChar, r.CourtName)\r\n        .input(\"RoleName\", sql.NVarChar, r.RoleName)\r\n        .input(\"Status\", sql.NVarChar, r.Status)\r\n        .input(\"RequestedAt\", sql.DateTime, r.RequestedAt)\r\n        .query(`\r\n          INSERT INTO MembershipRecords\r\n          (RequestID, ResidentName, NationalID, PhoneNumber, Email, HouseNumber, CourtName, RoleName, Status, RequestedAt)\r\n          VALUES (@RequestID,@ResidentName,@NationalID,@PhoneNumber,@Email,@HouseNumber,@CourtName,@RoleName,@Status,@RequestedAt)\r\n        `);\r\n\r\n      syncCount.inserted++;\r\n    }\r\n\r\n    res.json({ success: true, message: \"Sync completed\", syncCount });\r\n  } catch (error) {\r\n    console.error(\"âŒ Sync error:\", error);\r\n    res.status(500).json({ success: false, message: `Sync failed: ${error.message}` });\r\n  }\r\n};\r\n\r\n// ðŸ“‹ GET ALL MEMBERSHIP RECORDS\r\n/**\r\n * Fetches all records from the MembershipRecords table (used for general admin review).\r\n */\r\nexport const getAllMembershipRecords = async (req, res) => {\r\n  try {\r\n    const pool = await sql.connect(dbConfig);\r\n    const result = await pool.request().query(\"SELECT * FROM MembershipRecords ORDER BY RequestedAt DESC\");\r\n    res.json({ success: true, records: result.recordset });\r\n  } catch (error) {\r\n    res.status(500).json({ success: false, message: error.message });\r\n  }\r\n};\r\n\r\n// âœ… APPROVE MEMBERSHIP RECORD\r\n/**\r\n * Updates the Status to 'Approved' for a request in BOTH MembershipRecords and MembershipRequests.\r\n */\r\nexport const approveMembershipRecord = async (req, res) => {\r\n  const { id } = req.params;\r\n  try {\r\n    const pool = await sql.connect(dbConfig);\r\n\r\n    await pool.request().input(\"RequestID\", sql.Int, id).query(`\r\n      UPDATE MembershipRecords SET Status='Approved' WHERE RequestID=@RequestID;\r\n      UPDATE MembershipRequests SET Status='Approved' WHERE RequestID=@RequestID;\r\n    `);\r\n\r\n    res.json({ success: true, message: `Record ${id} approved` });\r\n  } catch (error) {\r\n    res.status(500).json({ success: false, message: error.message });\r\n  }\r\n};\r\n\r\n// âŒ REJECT MEMBERSHIP RECORD\r\n/**\r\n * Updates the Status to 'Rejected' for a request in BOTH MembershipRecords and MembershipRequests.\r\n */\r\nexport const rejectMembershipRecord = async (req, res) => {\r\n  const { id } = req.params;\r\n  try {\r\n    const pool = await sql.connect(dbConfig);\r\n\r\n    await pool.request().input(\"RequestID\", sql.Int, id).query(`\r\n      UPDATE MembershipRecords SET Status='Rejected' WHERE RequestID=@RequestID;\r\n      UPDATE MembershipRequests SET Status='Rejected' WHERE RequestID=@RequestID;\r\n    `);\r\n\r\n    res.json({ success: true, message: `Record ${id} rejected` });\r\n  } catch (error) {\r\n    res.status(500).json({ success: false, message: error.message });\r\n  }\r\n};\r\n\r\n// ðŸ—‘ï¸ DELETE MEMBERSHIP RECORD\r\n/**\r\n * Deletes a record from the MembershipRecords table (note: does not affect MembershipRequests).\r\n */\r\nexport const deleteMembershipRecord = async (req, res) => {\r\n  const { id } = req.params;\r\n  try {\r\n    const pool = await sql.connect(dbConfig);\r\n    await pool.request().input(\"RequestID\", sql.Int, id).query(\"DELETE FROM MembershipRecords WHERE RequestID=@RequestID\");\r\n    res.json({ success: true, message: `Record ${id} deleted` });\r\n  } catch (error) {\r\n    res.status(500).json({ success: false, message: error.message });\r\n  }\r\n};"
        }
    ]
}